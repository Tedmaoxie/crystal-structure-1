<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ™¶ä½“ç»“æ„å¯è§†åŒ–å±•ç¤ºç³»ç»Ÿbyå®éªŒä¸­å­¦</title>
    <style>
        :root {
            --bg-color: #050510;
            --panel-bg: rgba(20, 20, 35, 0.6);
            --text-main: #e0e0ff;
            --text-dim: #8080a0;
            --accent-color: #00f3ff;
            --accent-glow: 0 0 10px #00f3ff, 0 0 20px #00f3ff;
            --border-color: rgba(100, 100, 255, 0.2);
            --glass-blur: blur(12px);
        }

        * {
            box-sizing: border-box;
            user-select: none;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            color: var(--text-main);
        }

        sub {
            font-size: 70%;
            vertical-align: sub;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
            background: radial-gradient(circle at center, #0a0a20 0%, #000000 100%);
        }

        /* UI Overlay Layer */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none; /* Let clicks pass through to canvas */
            display: grid;
            grid-template-columns: 200px 1fr 200px;
            grid-template-rows: 60px 1fr 80px;
            padding: 20px;
            gap: 20px;
        }

        /* Common Panel Style */
        .glass-panel {
            background: var(--panel-bg);
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            pointer-events: auto;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
        }

        .glass-panel:hover {
            border-color: rgba(100, 200, 255, 0.4);
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.1);
        }

        /* Header */
        header {
            grid-column: 1 / -1;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
            background: linear-gradient(90deg, rgba(0,243,255,0.1) 0%, rgba(0,0,0,0) 100%);
            border-bottom: 1px solid var(--border-color);
        }

        h1 {
            font-size: 1.2rem;
            font-weight: 600;
            letter-spacing: 1px;
            margin: 0;
            text-shadow: 0 0 10px rgba(0, 243, 255, 0.5);
        }

        .mode-switch {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.9rem;
            cursor: pointer;
        }

        .switch-track {
            width: 40px;
            height: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            position: relative;
            transition: 0.3s;
        }

        .switch-track.active {
            background: var(--accent-color);
            box-shadow: var(--accent-glow);
        }

        .switch-knob {
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            position: absolute;
            top: 2px;
            left: 2px;
            transition: 0.3s;
        }

        .switch-track.active .switch-knob {
            transform: translateX(20px);
        }

        /* Navigation Sidebar */
        #nav-sidebar {
            grid-column: 1;
            grid-row: 2 / -1;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            padding: 10px;
        }

        .nav-category {
            margin-bottom: 20px;
        }

        .category-title {
            font-size: 0.75rem;
            color: var(--text-dim);
            text-transform: uppercase;
            margin-bottom: 8px;
            padding-left: 10px;
            border-left: 2px solid var(--accent-color);
        }

        .nav-item {
            padding: 10px 12px;
            margin-bottom: 4px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .nav-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .nav-item.active {
            background: rgba(0, 243, 255, 0.15);
            color: var(--accent-color);
            border-left: 3px solid var(--accent-color);
        }

        .nav-item.active::after {
            content: 'â—';
            font-size: 0.6rem;
            animation: blink 2s infinite;
        }

        /* Main View Area (HUD) */
        #hud-area {
            grid-column: 2;
            grid-row: 2;
            position: relative;
            pointer-events: none; /* Pass through to canvas */
        }

        #structure-info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            width: 100%;
            pointer-events: none;
        }

        #main-title {
            font-size: 2.5rem;
            font-weight: 700;
            margin: 0;
            background: linear-gradient(to bottom, #fff, #a0a0ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 10px rgba(100,100,255,0.5));
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.8s cubic-bezier(0.19, 1, 0.22, 1);
        }

        #sub-info {
            font-size: 1.2rem;
            color: var(--accent-color);
            margin-top: 8px;
            text-shadow: 0 0 5px rgba(0, 243, 255, 0.5);
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.8s cubic-bezier(0.19, 1, 0.22, 1) 0.1s;
        }

        #keywords-container {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: flex-end;
        }

        .keyword-tag {
            background: rgba(0, 243, 255, 0.1);
            border: 1px solid var(--accent-color);
            color: var(--accent-color);
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 0.8rem;
            /* text-transform: uppercase; */
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.2);
            opacity: 0;
            transform: translateX(20px);
            animation: slideInRight 0.5s forwards;
        }

        /* Right Panel (Details/Controls) */
        #details-panel {
            grid-column: 3;
            grid-row: 2;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .detail-item {
            margin-bottom: 15px;
        }

        .detail-label {
            font-size: 0.8rem;
            color: var(--text-dim);
            margin-bottom: 5px;
        }

        .detail-value {
            font-size: 1.1rem;
            font-weight: 500;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            box-shadow: 0 0 5px currentColor;
        }

        /* Bottom Controls */
        #bottom-controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            z-index: 200;
        }

        .control-btn {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.2);
            color: var(--text-main);
            padding: 10px 20px;
            border-radius: 30px;
            cursor: pointer;
            pointer-events: auto; /* å…è®¸é¼ æ ‡äº‹ä»¶ */
            position: relative;   /* ç¡®ä¿ z-index ç”Ÿæ•ˆ */
            z-index: 100;         /* æé«˜å±‚çº§ï¼Œé˜²æ­¢è¢«è¦†ç›– */
            font-size: 0.9rem;
            transition: 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-btn:hover {
            background: rgba(255,255,255,0.15);
            border-color: var(--text-main);
        }

        .control-btn.active {
            background: var(--accent-color);
            color: #000;
            box-shadow: var(--accent-glow);
            border-color: var(--accent-color);
        }

        /* Animations */
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        @keyframes slideInRight {
            to { opacity: 1; transform: translateX(0); }
        }

        .visible {
            opacity: 1 !important;
            transform: translateY(0) !important;
        }

        /* Button Active State */
        .control-btn:active {
            transform: scale(0.95);
            background: rgba(0, 243, 255, 0.3);
        }

        /* Loading */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--accent-color);
            font-size: 1.5rem;
            letter-spacing: 2px;
        }

    </style>
</head>
<body>

    <!-- Loading Screen -->
    <div id="loading">SYSTEM INITIALIZING...</div>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <!-- UI Layer -->
    <div id="ui-layer">
        
        <!-- Header -->
        <header class="glass-panel" style="border-radius: 0 0 12px 12px; border-top: none;">
            <div style="display: flex; align-items: center; gap: 15px;">
                <div style="width: 20px; height: 20px; background: var(--accent-color); border-radius: 50%; box-shadow: var(--accent-glow);"></div>
                <h1>AIèµ‹èƒ½é«˜ä¸­åŒ–å­¦æ•™å­¦ç³»åˆ—byå®éªŒä¸­å­¦ CRYSTAL VIS â€¢ æ™¶ä½“ç»“æ„å¯è§†åŒ–å±•ç¤ºç³»ç»Ÿ</h1>
            </div>
            
            <div class="mode-switch" onclick="toggleDemoMode()">
                <span>æ•™ç ”æ¼”ç¤ºæ¨¡å¼</span>
                <div class="switch-track active" id="demo-switch">
                    <div class="switch-knob"></div>
                </div>
            </div>
        </header>

        <!-- Sidebar Navigation -->
        <nav id="nav-sidebar" class="glass-panel">
            <!-- Content injected by JS -->
        </nav>

        <!-- CN Display -->
        <div id="cn-display" class="glass-panel" style="
            position: absolute; 
            top: 20px; 
            left: 50%; 
            transform: translateX(-50%); 
            padding: 10px 20px; 
            display: none; 
            z-index: 500;
            pointer-events: none;
            text-align: center;
        ">
            <div style="font-size: 0.8rem; color: var(--text-dim); margin-bottom: 4px;">é…ä½æ•° / CN</div>
            <div id="cn-value" style="font-size: 1.5rem; color: var(--accent-color); font-weight: bold;">-</div>
        </div>

        <!-- HUD Area -->
        <div id="hud-area">
            <div id="keywords-container">
                <!-- Keywords injected by JS -->
            </div>

            <div id="structure-info">
                <h2 id="main-title">Loading...</h2>
                <div id="sub-info">Description</div>
            </div>
        </div>

        <!-- Right Details Panel -->
        <aside id="details-panel" class="glass-panel">
            <div class="category-title">ç»“æ„å‚æ•° / PARAMETERS</div>
            <div class="detail-item">
                <div class="detail-label">æ™¶ç³» / System</div>
                <div class="detail-value" id="info-system">-</div>
            </div>
            <div class="detail-item">
                <div class="detail-label">é…ä½æ•° / CN</div>
                <div class="detail-value" id="info-cn">-</div>
            </div>
            <div class="detail-item">
                <div class="detail-label">åŸå­æ•°(æ™¶èƒ) / Z</div>
                <div class="detail-value" id="info-z">-</div>
            </div>
            
            <div class="category-title" style="margin-top: 20px;">å›¾ä¾‹ / LEGEND</div>
            <div id="legend-container">
                <!-- Legend items injected by JS -->
            </div>
        </aside>

        <!-- Bottom Controls -->
        <div id="bottom-controls">
            <button class="control-btn" onclick="resetView()">
                <span>âŸ²</span> å¤ä½è§†å›¾
            </button>
            <button class="control-btn active" id="dim-btn" onclick="toggleDimming()">
                <span>ğŸ’¡</span> æš—åŒ–èƒŒæ™¯: å¼€
            </button>
            <button class="control-btn" id="pause-btn" onclick="togglePause()">
                <span>âšâš</span> æš‚åœæ¼”ç¤º
            </button>
            <button class="control-btn" onclick="nextStructure()">
                <span>â–¶|</span> ä¸‹ä¸€ä¸ª
            </button>
        </div>

    </div>

    <!-- Libraries -->
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <!-- Application Logic -->
    <script>
        // --- å…¨å±€é…ç½®ä¸çŠ¶æ€ ---
        const CONFIG = {
            demoStepDuration: 8000, // (ä¸å†ç›´æ¥ç”¨äºæ€»æ—¶é•¿ï¼Œä¿ç•™ä½œä¸ºå‚è€ƒ)
            demoStayTime: 5000, // æ•´ä½“å±•ç¤ºåœç•™æ—¶é—´ (2s -> 5s)
            demoHighlightTime: 5000, // é…ä½é«˜äº®å±•ç¤ºæ—¶é—´
            transitionDuration: 1000,
            colors: {
                Na: 0xab5cf2, Cl: 0x1ff45d, Cs: 0x57178f,
                Ca: 0x3dff00, F: 0x90e0ef, Cu: 0xc88033, 
                O: 0xff0040, Zn: 0x7d8085, C: 0x808080, 
                Si: 0x4a5d7c, H: 0xffffff, I: 0x9400d3,
                Ti: 0xbfc2c7, N: 0x3050f8, S: 0xffff00,
                Po: 0xaaaaaa // æ·»åŠ  Po é¢œè‰²
            },
            // å®šä¹‰ç›¸å¯¹åŸå­/ç¦»å­åŠå¾„ (ç”¨äºè§†è§‰åŒºåˆ†å¤§å°)
            radii: {
                // é˜³ç¦»å­é€šå¸¸è¾ƒå°ï¼Œé˜´ç¦»å­é€šå¸¸è¾ƒå¤§
                Na: 0.19, Cl: 0.25,  // NaCl: Na+ < Cl-
                Cs: 0.22,            // CsCl: Cs+ > Na+, ä½† Cs+ < Cl- (0.169nm vs 0.181nm)
                Ca: 0.18, F: 0.15,   // CaF2: Ca2+ ~ F-
                Cu: 0.15, O: 0.18,   // Cu2O
                Zn: 0.15, S: 0.24,   // ZnS
                C: 0.20, H: 0.08,    // Organic
                Si: 0.18,            // Silicon
                I: 0.26,             // Iodine (Large)
                Ti: 0.14,            // Perovskite
                Po: 0.22,            // Simple Cubic
                N: 0.16
            },
            // å®šä¹‰ç”µè·/æ°§åŒ–æ€ (ç”¨äºé…ä½æ•°è®¡ç®—è§„åˆ™)
            charges: {
                Na: 1, Cl: -1, K: 1,
                Cs: 1,
                Ca: 2, F: -1,
                Cu: 1, O: -2, // Cu2O implies Cu+
                Zn: 2, S: -2,
                Ti: 4,
                H: 1,
                // å…±ä»·/é‡‘å±æ™¶ä½“å¯è§†ä½œ 0 æˆ–ä¸é€‚ç”¨
                C: 0, Si: 0, Po: 0, I: 0,
                Fe: 0, Ag: 0, Au: 0 // é‡‘å±è§†ä½œ 0
            },
            atomScale: 0.20,
            bondRadius: 0.02
        };

        let state = {
            demoMode: true,
            paused: false,
            currentIndex: 0,
            lastSwitchTime: 0,
            isTransitioning: false,
            selectedAtom: null, // Track selected atom for CN display
            enableDimming: true, // ç”¨æˆ·é€‰é¡¹ï¼šæ˜¯å¦åœ¨é…ä½é«˜äº®æ—¶æš—åŒ–å…¶ä»–åŸå­
            
            // Demo Mode Phases
            demoPhase: 0, // 0: Init/Whole, 1...N: Highlight Types, N+1: End Whole
            lastDemoActionTime: 0,
            demoTargets: [], // Indices of atoms to highlight
            demoActionDone: false
        };
        
        let currentStructureData = null; // Store current structure data for interaction

        // --- Data Definitions ---
        // ã€å·¥å…·å‡½æ•°ã€‘ç”ŸæˆåŸºç¡€æ™¶æ ¼ç‚¹é˜µ
        // å‚æ•° type: æ™¶æ ¼ç±»å‹ ('SC', 'BCC', 'FCC')
        const genLattice = (type, params = {}) => {
            const points = [];
            if(type === 'SC') { // Simple Cubic - ç®€å•ç«‹æ–¹
                // ç”Ÿæˆç«‹æ–¹ä½“çš„8ä¸ªé¡¶ç‚¹ (0,0,0) åˆ° (1,1,1)
                for(let x=0; x<=1; x++) for(let y=0; y<=1; y++) for(let z=0; z<=1; z++) 
                    points.push({x,y,z});
            } else if(type === 'BCC') { // Body-Centered Cubic - ä½“å¿ƒç«‹æ–¹
                // 1. ç”Ÿæˆ8ä¸ªé¡¶ç‚¹
                for(let x=0; x<=1; x++) for(let y=0; y<=1; y++) for(let z=0; z<=1; z++) 
                    points.push({x,y,z});
                // 2. æ·»åŠ ä½“å¿ƒçš„ä¸€ä¸ªç‚¹
                points.push({x:0.5, y:0.5, z:0.5});
            } else if(type === 'FCC') { // Face-Centered Cubic - é¢å¿ƒç«‹æ–¹
                // 1. ç”Ÿæˆ8ä¸ªé¡¶ç‚¹
                for(let x=0; x<=1; x++) for(let y=0; y<=1; y++) for(let z=0; z<=1; z++) 
                    points.push({x,y,z});
                // 2. æ·»åŠ 6ä¸ªé¢çš„ä¸­å¿ƒç‚¹
                // (ä¸Šä¸‹, å‰å, å·¦å³é¢çš„ä¸­å¿ƒ)
                [[0.5,0.5,0], [0.5,0.5,1], [0.5,0,0.5], [0.5,1,0.5], [0,0.5,0.5], [1,0.5,0.5]]
                .forEach(p => points.push({x:p[0], y:p[1], z:p[2]}));
            }
            return points;
        };

        const structures = [
            // --- 1. æ™¶èƒåŸºç¡€ ---
            {
                id: 'sc', category: 'åŸºç¡€æ™¶èƒ', title: 'ç®€å•ç«‹æ–¹å †ç§¯',
                keywords: ['é…ä½æ•°: 6', 'ç©ºé—´åˆ©ç”¨ç‡: 52%', 'Po (é’‹)'],
                info: { system: 'ç«‹æ–¹æ™¶ç³»', cn: '6', z: '1' },
                generator: () => {
                    const atoms = genLattice('SC').map(p => ({...p, el: 'Po'}));
                    return { 
                        atoms, 
                        bonds: getBonds(atoms, 1.01),
                        cell: { type: 'cubic', a: 1 }
                    };
                }
            },
            {
                id: 'bcc', category: 'åŸºç¡€æ™¶èƒ', title: 'ä½“å¿ƒç«‹æ–¹å †ç§¯ (BCC)',
                keywords: ['é…ä½æ•°: 8', 'ç©ºé—´åˆ©ç”¨ç‡: 68%', 'Na, K, Fe'],
                info: { system: 'ç«‹æ–¹æ™¶ç³»', cn: '8', z: '2' },
                generator: () => {
                    const atoms = genLattice('BCC').map(p => ({...p, el: 'Na'}));
                    return { 
                        atoms, 
                        bonds: getBonds(atoms, 0.87),
                        cell: { type: 'cubic', a: 1 }
                    };
                }
            },
            {
                id: 'fcc', category: 'åŸºç¡€æ™¶èƒ', title: 'é¢å¿ƒç«‹æ–¹å †ç§¯ (FCC)',
                keywords: ['é…ä½æ•°: 12', 'ç©ºé—´åˆ©ç”¨ç‡: 74%', 'Cu, Ag, Au'],
                info: { system: 'ç«‹æ–¹æ™¶ç³»', cn: '12', z: '4' },
                generator: () => {
                    const atoms = genLattice('FCC').map(p => ({...p, el: 'Cu'}));
                    return { 
                        atoms, 
                        bonds: getBonds(atoms, 0.71),
                        cell: { type: 'cubic', a: 1 }
                    };
                }
            },
            // --- 2. ç¦»å­æ™¶ä½“ ---
            {
                id: 'nacl', category: 'ç¦»å­æ™¶ä½“', title: 'æ°¯åŒ–é’  (NaCl)',
                keywords: ['é…ä½æ•°: 6', 'ç¦»å­é”®', 'å²©ç›ç»“æ„'],
                info: { system: 'ç«‹æ–¹æ™¶ç³»', cn: '6:6', z: '4' },
                generator: () => {
                    const atoms = [];
                    genLattice('FCC').forEach(p => atoms.push({...p, el: 'Cl'}));
                    [[0.5,0,0],[0.5,1,0],[0,0.5,0],[1,0.5,0],[0,0,0.5],[0,1,0.5],[1,0,0.5],[1,1,0.5],
                     [0.5,0.5,0.5],[0.5,0,1],[0.5,1,1],[0,0.5,1],[1,0.5,1]]
                    .forEach(p => atoms.push({x:p[0], y:p[1], z:p[2], el: 'Na'}));
                    return { 
                        atoms, 
                        bonds: getBonds(atoms, 0.6),
                        cell: { type: 'cubic', a: 1 }
                    };
                }
            },
            {
                id: 'cscl', category: 'ç¦»å­æ™¶ä½“', title: 'æ°¯åŒ–é“¯ (CsCl)',
                keywords: ['é…ä½æ•°: 8', 'ç®€å•ç«‹æ–¹Cl-', 'ä½“å¿ƒCs+'],
                info: { system: 'ç«‹æ–¹æ™¶ç³»', cn: '8:8', z: '1' },
                generator: () => {
                    const atoms = genLattice('SC').map(p => ({...p, el: 'Cl'}));
                    atoms.push({x:0.5, y:0.5, z:0.5, el: 'Cs'});
                    return { 
                        atoms, 
                        bonds: getBonds(atoms, 0.9),
                        cell: { type: 'cubic', a: 1 }
                    };
                }
            },
            {
                id: 'caf2', category: 'ç¦»å­æ™¶ä½“', title: 'æ°ŸåŒ–é’™ (CaF2)',
                keywords: ['è¤çŸ³ç»“æ„', 'é…ä½æ•° 8:4', 'CaÂ²âºé¢å¿ƒç«‹æ–¹'],
                info: { system: 'ç«‹æ–¹æ™¶ç³»', cn: '8:4', z: '4' },
                generator: () => {
                    const atoms = genLattice('FCC').map(p => ({...p, el: 'Ca'}));
                    const holes = [
                        [0.25,0.25,0.25], [0.75,0.25,0.25], [0.25,0.75,0.25], [0.75,0.75,0.25],
                        [0.25,0.25,0.75], [0.75,0.25,0.75], [0.25,0.75,0.75], [0.75,0.75,0.75]
                    ];
                    holes.forEach(p => atoms.push({x:p[0], y:p[1], z:p[2], el: 'F'}));
                    return { 
                        atoms, 
                        bonds: getBonds(atoms, 0.5),
                        cell: { type: 'cubic', a: 1 }
                    };
                }
            },
            {
                id: 'cu2o', category: 'ç¦»å­æ™¶ä½“', title: 'æ°§åŒ–äºšé“œ (Cu2O)',
                keywords: ['èµ¤é“œçŸ¿', 'Cuâºç›´çº¿å‹é…ä½', 'OÂ²â»å››é¢ä½“é…ä½'],
                info: { system: 'ç«‹æ–¹æ™¶ç³»', cn: '2:4', z: '2' },
                generator: () => {
                    const atoms = [];
                    // O: BCC Lattice Points (Corners + Body Center)
                    // Corners
                    for(let x=0; x<=1; x++) for(let y=0; y<=1; y++) for(let z=0; z<=1; z++) 
                        atoms.push({x, y, z, el: 'O'});
                    // Body Center
                    atoms.push({x:0.5, y:0.5, z:0.5, el: 'O'});
                    
                    // Cu: Tetrahedral sites (4 inside cell)
                    const cuPos = [
                        [0.25, 0.25, 0.25], [0.75, 0.75, 0.25],
                        [0.75, 0.25, 0.75], [0.25, 0.75, 0.75]
                    ];
                    cuPos.forEach(p => atoms.push({x:p[0], y:p[1], z:p[2], el: 'Cu'}));
                    
                    return { 
                        atoms, 
                        bonds: getBonds(atoms, 0.45),
                        cell: { type: 'cubic', a: 1 }
                    };
                }
            },
            {
                id: 'zns', category: 'ç¦»å­æ™¶ä½“', title: 'ç¡«åŒ–é”Œ (ZnS)',
                keywords: ['é—ªé”ŒçŸ¿', 'F-43m', 'é‡‘åˆšçŸ³ç»“æ„'],
                info: { system: 'ç«‹æ–¹æ™¶ç³»', cn: '4:4', z: '4' },
                generator: () => {
                    const atoms = [];
                    // 1. ç”Ÿæˆ Zn åŸå­ï¼šé¢å¿ƒç«‹æ–¹ç‚¹é˜µ (FCC)
                    // åŒ…å«æ‰€æœ‰é¡¶ç‚¹å’Œé¢å¿ƒ (0 åˆ° 1 çš„èŒƒå›´)
                    const fcc = genLattice('FCC');
                    fcc.forEach(p => {
                        atoms.push({...p, el: 'Zn'});
                    });

                    // 2. ç”Ÿæˆ S åŸå­ï¼šå¡«å……åœ¨å››é¢ä½“ç©ºéš™ä¸­
                    // ä»…æ·»åŠ ä½äºæ™¶èƒå†…éƒ¨çš„4ä¸ªç¡«åŸå­ï¼Œä¸è¿›è¡Œé¢å¤–çš„åç§»å’ŒæŠ˜å ï¼Œé¿å…ä¸¢å¤±
                    const sPos = [
                        {x: 0.25, y: 0.25, z: 0.25},
                        {x: 0.75, y: 0.75, z: 0.25},
                        {x: 0.75, y: 0.25, z: 0.75},
                        {x: 0.25, y: 0.75, z: 0.75}
                    ];
                    sPos.forEach(p => {
                        atoms.push({...p, el: 'S'});
                    });
                    
                    return { 
                        atoms, 
                        bonds: getBonds(atoms, 0.45),
                        cell: { type: 'cubic', a: 1 },
                        cifData: {
                            a: 5.41, b: 5.41, c: 5.41,
                            alpha: 90, beta: 90, gamma: 90,
                            sg: 'F-43m',
                            atoms: [
                                { label: 'Zn', x: 0, y: 0, z: 0 },
                                { label: 'S', x: 0.25, y: 0.25, z: 0.25 }
                            ]
                        }
                    };
                }
            },
            // --- 3. é‡‘å±æ™¶ä½“ ---
            {
                id: 'cu', category: 'é‡‘å±æ™¶ä½“', title: 'é“œ (Cu)',
                keywords: ['é‡‘å±é”®', 'æœ€å¯†å †ç§¯', 'å»¶å±•æ€§'],
                info: { system: 'é¢å¿ƒç«‹æ–¹', cn: '12', z: '4' },
                generator: () => {
                    const atoms = genLattice('FCC').map(p => ({...p, el: 'Cu'}));
                    return { 
                        atoms, 
                        bonds: getBonds(atoms, 0.71),
                        cell: { type: 'cubic', a: 1 }
                    };
                }
            },
            {
                id: 'na_metal', category: 'é‡‘å±æ™¶ä½“', title: 'é’  (Na)',
                keywords: ['ä½“å¿ƒç«‹æ–¹å †ç§¯', 'è´¨è½¯', 'ç†”ç‚¹ä½'],
                info: { system: 'ä½“å¿ƒç«‹æ–¹', cn: '8', z: '2' },
                generator: () => {
                    const atoms = genLattice('BCC').map(p => ({...p, el: 'Na'}));
                    return { 
                        atoms, 
                        bonds: getBonds(atoms, 0.87),
                        cell: { type: 'cubic', a: 1 }
                    };
                }
            },
            {
                id: 'zn', category: 'é‡‘å±æ™¶ä½“', title: 'é”Œ (Zn)',
                keywords: ['å…­æ–¹æœ€å¯†å †ç§¯ (HCP)', 'ABAB...', 'Z=2'],
                info: { system: 'å…­æ–¹æ™¶ç³»', cn: '12', z: '2' },
                generator: () => {
                    const atoms = [];
                    const c_h = 1.633;
                    const toCart = (u,v,w) => ({
                        x: u - 0.5 * v,
                        y: 0.866 * v,
                        z: w * c_h,
                        el: 'Zn'
                    });
                    const corners = [
                        [0,0,0], [1,0,0], [0,1,0], [1,1,0],
                        [0,0,1], [1,0,1], [0,1,1], [1,1,1]
                    ];
                    corners.forEach(p => atoms.push(toCart(p[0], p[1], p[2])));
                    atoms.push(toCart(2/3, 1/3, 0.5));
                    
                    return { 
                        atoms, 
                        bonds: getBonds(atoms, 1.1),
                        cell: { type: 'hexagonal', a: 1, c: c_h }
                    };
                }
            },
            // --- 4. å…±ä»·æ™¶ä½“ ---
            {
                id: 'diamond', category: 'å…±ä»·æ™¶ä½“', title: 'é‡‘åˆšçŸ³ (C)',
                keywords: ['å…±ä»·é”®', 'æ­£å››é¢ä½“ç»“æ„', 'ç¡¬åº¦æå¤§'],
                info: { system: 'ç«‹æ–¹æ™¶ç³»', cn: '4', z: '8' },
                generator: () => {
                    const atoms = [];
                    const fcc = genLattice('FCC');
                    fcc.forEach(p => atoms.push({...p, el: 'C'}));
                    const basis = [
                        {x:0.25, y:0.25, z:0.25}, 
                        {x:0.25, y:0.75, z:0.75}, 
                        {x:0.75, y:0.25, z:0.75}, 
                        {x:0.75, y:0.75, z:0.25}
                    ];
                    basis.forEach(b => atoms.push({...b, el: 'C'}));

                    const eps = 0.01;
                    const validAtoms = atoms.filter(a => 
                        a.x >= -eps && a.x <= 1+eps &&
                        a.y >= -eps && a.y <= 1+eps &&
                        a.z >= -eps && a.z <= 1+eps
                    );
                    return { 
                        atoms: validAtoms, 
                        bonds: getBonds(validAtoms, 0.45),
                        cell: { type: 'cubic', a: 1 }
                    };
                }
            },
            {
                id: 'si', category: 'å…±ä»·æ™¶ä½“', title: 'æ™¶ä½“ç¡… (Si)',
                keywords: ['åŠå¯¼ä½“', 'åŒé‡‘åˆšçŸ³ç»“æ„', 'é”®é•¿è¾ƒé•¿'],
                info: { system: 'ç«‹æ–¹æ™¶ç³»', cn: '4', z: '8' },
                generator: () => {
                    const data = structures.find(s=>s.id==='diamond').generator();
                    data.atoms.forEach(a => a.el = 'Si');
                    return data;
                }
            },
            // --- 5. åˆ†å­æ™¶ä½“ ---
            {
                id: 'i2', category: 'åˆ†å­æ™¶ä½“', title: 'ç¢˜ (I2)',
                keywords: ['æ­£äº¤æ™¶ç³»', 'Cmca', 'å±‚çŠ¶ç»“æ„'],
                info: { system: 'æ­£äº¤æ™¶ç³»', cn: '12', z: '4' },
                type: 'molecular', // æ ‡è®°ä¸ºåˆ†å­æ™¶ä½“
                generator: () => {
                    // I2 ç»“æ„ï¼šç”¨æˆ·è¦æ±‚ç®€åŒ–ä¸ºé•¿æ–¹ä½“æ™¶èƒ (æ­£äº¤æ™¶ç³»)
                    // ä½¿ç”¨ FCC å †ç§¯æ¨¡å¼ï¼Œä½†å°†æ™¶èƒæ‹‰ä¼¸ä¸ºé•¿æ–¹ä½“ (a:b:c ä¸ç›¸ç­‰)
                    
                    // è®¾å®šé•¿æ–¹ä½“æ¯”ä¾‹ (æ¨¡æ‹Ÿç¢˜æ™¶ä½“çš„å±‚çŠ¶/æ­£äº¤ç‰¹å¾)
                    // a, b, c æ¯”ä¾‹è®¾å®š (æ‰©å¤§æ™¶èƒå¤§å°ï¼Œé¿å…åŸå­é‡å )
                    const scaleA = 0.72 * 1.6; // æ‰©å¤§ 1.6 å€
                    const scaleB = 0.47 * 1.6;
                    const scaleC = 0.98 * 1.6;

                    const atoms = [];
                    // ä½¿ç”¨é¢å¿ƒç«‹æ–¹ (FCC) ç‚¹é˜µä½œä¸ºåŸºç¡€
                    const fcc = genLattice('FCC');
                    
                    fcc.forEach((p, idx) => {
                        // å°† FCC çš„ 0-1 åæ ‡æ˜ å°„åˆ°é•¿æ–¹ä½“å°ºå¯¸
                        const x = p.x * scaleA;
                        const y = p.y * scaleB;
                        const z = p.z * scaleC;
                        
                        // åœ¨æ¯ä¸ªæ™¶æ ¼ç‚¹æ”¾ç½®ä¸€ä¸ª I2 åˆ†å­ (ä¸¤ä¸ªç¢˜åŸå­)
                        // åˆ†å­å–å‘ï¼šæ ¹æ®å±‚ (zåæ ‡) äº¤æ›¿å˜åŒ–ï¼Œæ¨¡æ‹Ÿ Cmca ç»“æ„çš„é±¼éª¨çŠ¶æ’åˆ—
                        const bondLen = 0.15; // I-I é”®é•¿çš„ä¸€åŠ
                        
                        // åˆ¤æ–­å±‚ï¼šz æ¥è¿‘ 0 æˆ– 1 ä¸º A å±‚ï¼Œæ¥è¿‘ 0.5 ä¸º B å±‚
                        const isLayerB = Math.abs((p.z % 1) - 0.5) < 0.1;
                        
                        // è®¾ç½®ä¸¤ç§ä¸åŒçš„å€¾æ–œè§’ (ç»• Y è½´æ—‹è½¬)
                        // A å±‚å€¾æ–œ +35åº¦ï¼ŒB å±‚å€¾æ–œ -35åº¦
                        const angle = isLayerB ? (35 * Math.PI / 180) : (-35 * Math.PI / 180);
                        
                        const dx = bondLen * Math.sin(angle);
                        const dz = bondLen * Math.cos(angle);
                        
                        // åˆ†å­ ID (moleculeId)
                        const molId = idx;

                        atoms.push({
                            x: x + dx, 
                            y: y, 
                            z: z - dz, 
                            el: 'I',
                            moleculeId: molId
                        });
                        atoms.push({
                            x: x - dx, 
                            y: y, 
                            z: z + dz, 
                            el: 'I',
                            moleculeId: molId
                        });
                    });

                    return { 
                        atoms, 
                        // è°ƒæ•´é”®é•¿é˜ˆå€¼ä»¥è¿æ¥åˆ†å­å†…çš„åŸå­
                        bonds: getBonds(atoms, 0.35), 
                        cell: { type: 'orthorhombic', a: scaleA, b: scaleB, c: scaleC },
                        cifData: {
                            a: 7.18, b: 4.71, c: 9.81,
                            alpha: 90, beta: 90, gamma: 90,
                            sg: 'Cmca',
                            atoms: [
                                { label: 'I', x: 0, y: 0.1543, z: 0.1174 }
                            ]
                        }
                    };
                }
            },
            {
                id: 'co2', category: 'åˆ†å­æ™¶ä½“', title: 'å¹²å†° (CO2)',
                keywords: ['Pa3ç©ºé—´ç¾¤', 'é¢å¿ƒç«‹æ–¹å †ç§¯', 'ç›´çº¿å‹åˆ†å­'],
                info: { system: 'ç«‹æ–¹æ™¶ç³»', cn: '12', z: '4' },
                type: 'molecular', // æ ‡è®°ä¸ºåˆ†å­æ™¶ä½“
                generator: () => {
                    const atoms = [];
                    const centers = genLattice('FCC');
                    centers.forEach((p, idx) => {
                        // C atom
                        atoms.push({x:p.x, y:p.y, z:p.z, el: 'C', moleculeId: idx});
                        
                        const d = 0.12; // C=O bond length component
                        let dir = {x:1, y:1, z:1}; // Default (1,1,1)

                        // Determine orientation based on position (Pa3 structure)
                        // 4 sublattices of FCC:
                        // 1. (0,0,0) + integers -> (1,1,1)
                        // 2. (0.5, 0.5, 0) + integers -> (1,1,-1)  (Face XY)
                        // 3. (0.5, 0, 0.5) + integers -> (1,-1,1)  (Face XZ)
                        // 4. (0, 0.5, 0.5) + integers -> (-1,1,1)  (Face YZ)
                        
                        // Check if coordinates are integers (or close to)
                        const isInt = (v) => Math.abs(v - Math.round(v)) < 0.1;
                        
                        if (isInt(p.x) && isInt(p.y) && isInt(p.z)) {
                            // Vertices / Corners
                            dir = {x:1, y:1, z:1};
                        } else if (!isInt(p.z)) {
                            // z is half-integer -> Face XY center? No, face centers have one 0 coord in simple cell.
                            // In FCC lattice points generated by genLattice('FCC'):
                            // Vertices: (0,0,0) etc.
                            // Face centers:
                            // (0.5, 0.5, 0) -> z is int. x,y half.
                            // (0.5, 0.5, 1) -> z is int.
                            // (0.5, 0, 0.5) -> y is int. x,z half.
                            // (0, 0.5, 0.5) -> x is int. y,z half.
                            
                            if (isInt(p.y)) { 
                                // (0.5, 0, 0.5) type -> Face XZ
                                dir = {x:1, y:-1, z:1}; // Orientation C
                            } else if (isInt(p.x)) {
                                // (0, 0.5, 0.5) type -> Face YZ
                                dir = {x:-1, y:1, z:1}; // Orientation D
                            }
                        } else {
                            // z is int (0 or 1). x,y must be half.
                            // (0.5, 0.5, 0) type -> Face XY
                            dir = {x:1, y:1, z:-1}; // Orientation B
                        }
                        
                        const dx = d * dir.x;
                        const dy = d * dir.y;
                        const dz = d * dir.z;

                        // O atoms
                        atoms.push({x:p.x+dx, y:p.y+dy, z:p.z+dz, el: 'O', radius: 0.18, moleculeId: idx});
                        atoms.push({x:p.x-dx, y:p.y-dy, z:p.z-dz, el: 'O', radius: 0.18, moleculeId: idx});
                    });
                    
                    return { 
                        atoms, 
                        bonds: getBonds(atoms, 0.35),
                        cell: { type: 'cubic', a: 1 }
                    }; 
                }
            },
            {
                id: 'ice', category: 'åˆ†å­æ™¶ä½“', title: 'å†° (H2O)',
                keywords: ['æ°¢é”®', 'å››é¢ä½“æ–¹å‘', 'å…­æ–¹æ™¶ç³»'],
                info: { system: 'å…­æ–¹æ™¶ç³»', cn: '4', z: '4' },
                generator: () => {
                    const atoms = [];
                    const bonds = [];
                    const c_a = 1.6;
                    const toCart = (u,v,w) => ({
                        x: u - 0.5 * v,
                        y: 0.866 * v,
                        z: w * c_a,
                        el: 'O'
                    });

                    // Ice Ih Lattice
                    const o_fracs = [
                        [0,0,0], [0,0,0.375],
                        [2/3,1/3,0.5], [2/3,1/3,0.875],
                        // Corners for visual completeness
                        [1,0,0], [1,0,0.375], [0,1,0], [0,1,0.375], [1,1,0], [1,1,0.375],
                        [0,0,1], [1,0,1], [0,1,1], [1,1,1]
                    ];
                    
                    const oxygens = [];
                    o_fracs.forEach((p, i) => {
                        const o = toCart(p[0], p[1], p[2]);
                        o.isOxygen = true; // marker
                        o.idx = i; // æ·»åŠ ç´¢å¼•ç”¨äºå»é‡
                        atoms.push(o);
                        oxygens.push(o);
                    });

                    // Add Hydrogens & Bonds
                    // Simplified: Place H towards nearest neighbors
                    for(let i=0; i<oxygens.length; i++) {
                        const o1 = oxygens[i];
                        let neighbors = [];
                        for(let j=0; j<oxygens.length; j++) {
                            if(i===j) continue;
                            const o2 = oxygens[j];
                            const dist = Math.hypot(o1.x-o2.x, o1.y-o2.y, o1.z-o2.z);
                            if(dist < 0.8) neighbors.push(o2);
                        }
                        
                        // Sort by distance and pick closest 4 (tetrahedral)
                        neighbors.sort((a,b) => {
                             const da = Math.hypot(o1.x-a.x, o1.y-a.y, o1.z-a.z);
                             const db = Math.hypot(o1.x-b.x, o1.y-b.y, o1.z-b.z);
                             return da - db;
                        });
                        
                        // We need 2 covalent H's and 2 H-bonds per Oxygen roughly
                        for(let k=0; k<Math.min(neighbors.length, 4); k++) {
                            const o2 = neighbors[k];
                            // Check if bond already exists
                            // ä¿®å¤ï¼šä½¿ç”¨ç´¢å¼•æ¯”è¾ƒä»£æ›¿ x åæ ‡æ¯”è¾ƒï¼Œé¿å…æ¼æ‰å‚ç›´æ–¹å‘(xç›¸åŒ)çš„é”®
                            if(o1.idx < o2.idx) { 
                                // H-bond logic: One O has H, other accepts
                                // Visualize: Solid bond O-H, Dotted H...O
                                // ä¿®æ”¹ï¼šå°†HåŸå­åˆå§‹ä½ç½®è®¾ä¸ºä¸¤ä¸ªæ°§åŸå­çš„ä¸­ç‚¹ (0.5)ï¼Œä»¥ä¾¿äºè¿›è¡Œä»ä¸€ç«¯åˆ°å¦ä¸€ç«¯çš„æŒ¯è¡åŠ¨ç”»
                                const hx = o1.x + (o2.x-o1.x)*0.5;
                                const hy = o1.y + (o2.y-o1.y)*0.5;
                                const hz = o1.z + (o2.z-o1.z)*0.5;
                                
                                const hAtom = {x:hx, y:hy, z:hz, el:'H'};
                                
                                // æ·»åŠ æŒ¯åŠ¨åŠ¨ç”»æ•°æ® (ç”¨æˆ·è¯·æ±‚: æ¨¡æ‹Ÿ 3000cm^-1 ä¼¸ç¼©æŒ¯åŠ¨)
                                // æŒ¯åŠ¨æ–¹å‘æ²¿ O-H...O è¿çº¿æ–¹å‘ (å³ o2 - o1)
                                hAtom.animData = {
                                    type: 'oscillation',
                                    dir: { x: o2.x-o1.x, y: o2.y-o1.y, z: o2.z-o1.z }, // æ–¹å‘å‘é‡
                                    phase: Math.random() * Math.PI * 2 // éšæœºç›¸ä½ï¼Œé¿å…æ‰€æœ‰åŸå­åŒæ­¥æŒ¯åŠ¨
                                };
                                
                                atoms.push(hAtom);
                                
                                // Covalent Bond
                                bonds.push({start: o1, end: hAtom});
                                
                                // Hydrogen Bond (Translucent)
                                bonds.push({start: hAtom, end: o2, type: 'hbond'});
                            }
                        }
                    }

                    return { 
                        atoms, 
                        bonds,
                        cell: { type: 'hexagonal', a: 1, c: c_a }
                    };
                }
            },

            // --- 5. æ··åˆå‹æ™¶ä½“ ---
            {
                id: 'graphite', category: 'æ··åˆå‹æ™¶ä½“', title: 'çŸ³å¢¨ (C)',
                keywords: ['å±‚çŠ¶ç»“æ„', 'å¤§Ï€é”®', 'å…­æ–¹æ™¶ç³»'],
                info: { system: 'å…­æ–¹æ™¶ç³»', cn: '3', z: '4' },
                generator: () => {
                    const atoms = [];
                    // çŸ³å¢¨æ™¶èƒå‚æ•°
                    const a = 2.46;
                    const c = 6.70;
                    const c_ratio = c/a; // ~2.72

                    // æ™¶èƒå†…çš„4ä¸ªç¢³åŸå­ (P63/mmc) ä»¥åŠä¸ºäº†è§†è§‰å®Œæ•´æ€§è¡¥å……çš„è¾¹ç•ŒåŸå­
                    const coords = [
                        // Layer A (z=0)
                        {x: 0, y: 0, z: 0},
                        {x: 1/3, y: 2/3, z: 0},
                        
                        // Layer B (z=0.5)
                        {x: 0, y: 0, z: 0.5},
                        {x: 2/3, y: 1/3, z: 0.5},

                        // --- è§†è§‰è¾¹ç•Œè¡¥å…… (Visual Boundary) ---
                        // x, y æ–¹å‘çš„å‘¨æœŸæ€§å‰¯æœ¬ (é’ˆå¯¹ä½äºåŸç‚¹ 0,0 çš„åŸå­)
                        {x: 1, y: 0, z: 0}, {x: 0, y: 1, z: 0}, {x: 1, y: 1, z: 0},
                        {x: 1, y: 0, z: 0.5}, {x: 0, y: 1, z: 0.5}, {x: 1, y: 1, z: 0.5},

                        // z æ–¹å‘çš„å‘¨æœŸæ€§å‰¯æœ¬ (å³ Top Face z=1ï¼Œå¤åˆ¶æ‰€æœ‰ z=0 çš„åŸå­)
                        {x: 0, y: 0, z: 1}, {x: 1/3, y: 2/3, z: 1},
                        {x: 1, y: 0, z: 1}, {x: 0, y: 1, z: 1}, {x: 1, y: 1, z: 1}
                    ];

                    // å…­æ–¹æ™¶ç³»åæ ‡è½¬æ¢
                    const toCart = (u,v,w) => ({
                        x: u - 0.5 * v,
                        y: 0.866 * v,
                        z: w * c_ratio,
                        el: 'C'
                    });

                    coords.forEach(p => {
                        atoms.push(toCart(p.x, p.y, p.z));
                    });
                    
                    // é”®è¿ï¼šå±‚å†…å…±ä»·é”®
                    // é”®é•¿çº¦ 1.42A (å³ a/sqrt(3))
                    // åœ¨å¯è§†åŒ–æ¯”ä¾‹ä¸­ï¼Œa=1ï¼Œé”®é•¿çº¦ 0.577
                    // é˜ˆå€¼è®¾ä¸º 0.65 å³å¯è¿æ¥å±‚å†…ï¼Œæ’é™¤å±‚é—´ (å±‚é—´çº¦ 2.72/2 = 1.36)
                    
                    return { 
                        atoms, 
                        bonds: getBonds(atoms, 0.65), 
                        cell: { type: 'hexagonal', a: 1, c: c_ratio }
                    };
                }
            },
            // --- 6. æ‹”é«˜ä¸æ‹“å±• ---
            {
                id: 'catio3', category: 'æ‹“å±•ç»“æ„', title: 'é’™é’›çŸ¿ (CaTiO3)',
                keywords: ['ABO3å‹', 'å…«é¢ä½“ç©ºéš™', 'é«˜æ¸©è¶…å¯¼æ¯ä½“'],
                info: { system: 'ç«‹æ–¹æ™¶ç³»', cn: '12:6', z: '1' },
                generator: () => {
                    const atoms = [];
                    genLattice('SC').forEach(p => atoms.push({...p, el: 'Ca'}));
                    atoms.push({x:0.5, y:0.5, z:0.5, el: 'Ti'});
                    [[0.5,0.5,0], [0.5,0.5,1], [0.5,0,0.5], [0.5,1,0.5], [0,0.5,0.5], [1,0.5,0.5]]
                    .forEach(p => atoms.push({x:p[0], y:p[1], z:p[2], el: 'O'}));
                    return { 
                        atoms, 
                        bonds: getBonds(atoms, 0.6),
                        cell: { type: 'cubic', a: 1 }
                    };
                }
            }
        ];

        // Helper: Find bonds based on distance
        function getBonds(atoms, maxDist) {
            const bonds = [];
            for(let i=0; i<atoms.length; i++) {
                for(let j=i+1; j<atoms.length; j++) {
                    const dx = atoms[i].x - atoms[j].x;
                    const dy = atoms[i].y - atoms[j].y;
                    const dz = atoms[i].z - atoms[j].z;
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    if(dist < maxDist && dist > 0.01) {
                        bonds.push({start: atoms[i], end: atoms[j]});
                    }
                }
            }
            return bonds;
        }

        // --- Three.js Implementation ---
        let scene, camera, renderer, controls;
        let rootGroup;
        let frameId;
        
        // äº¤äº’ç›¸å…³
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let ghostGroup; // ç”¨äºå­˜æ”¾ä¸´æ—¶ç”Ÿæˆçš„"å¹½çµåŸå­"

        function init() {
            // Setup
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            // Fog for depth
            scene.fog = new THREE.FogExp2(0x050510, 0.15);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 100);
            camera.position.set(3, 2, 3);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            container.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 1.0;

            // Lights
            const ambient = new THREE.AmbientLight(0x404040, 3.5); // å¢åŠ ç¯å¢ƒå…‰å¼ºåº¦ (2 -> 3.5)
            scene.add(ambient);

            const pointLight = new THREE.PointLight(0xffffff, 1.2); // ç¨å¾®å¢å¼ºç‚¹å…‰æº
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);
            
            const blueLight = new THREE.PointLight(0x00f3ff, 2.5, 30); // å¢å¼ºè“è‰²è¡¥å…‰
            blueLight.position.set(-5, 5, -5);
            scene.add(blueLight);

            // Root Group for structures
            rootGroup = new THREE.Group();
            scene.add(rootGroup);

            // Ghost Group for CN highlighting
            ghostGroup = new THREE.Group();
            scene.add(ghostGroup);

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            
            // ä¼˜åŒ–äº¤äº’ï¼šåŒºåˆ†ç‚¹å‡»å’Œæ‹–æ‹½
            // window.addEventListener('click', onMouseClick, false);
            const canvas = renderer.domElement;
            let isDragging = false;
            let mouseDownTime = 0;
            let startMouse = new THREE.Vector2();

            canvas.addEventListener('pointerdown', (e) => {
                isDragging = false;
                mouseDownTime = Date.now();
                startMouse.x = e.clientX;
                startMouse.y = e.clientY;
            });

            canvas.addEventListener('pointermove', (e) => {
                // å¦‚æœç§»åŠ¨è·ç¦»è¶…è¿‡é˜ˆå€¼ï¼Œè§†ä¸ºæ‹–æ‹½
                if (Math.abs(e.clientX - startMouse.x) > 5 || Math.abs(e.clientY - startMouse.y) > 5) {
                    isDragging = true;
                }
            });

            canvas.addEventListener('pointerup', (e) => {
                const timeDiff = Date.now() - mouseDownTime;
                // å¦‚æœæ˜¯çŸ­æŒ‰ä¸”æœªå‘ç”Ÿæ˜¾è‘—ä½ç§»ï¼Œåˆ™è§†ä¸ºç‚¹å‡»
                if (!isDragging && timeDiff < 300) {
                    onMouseClick(e);
                }
            });

            // Start loop
            animate();
            
            // UI Init
            initUI();
            
            // Load first
            document.getElementById('loading').style.display = 'none';
            controls.saveState(); // Save initial view for reset
            loadStructure(0);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- äº¤äº’é€»è¾‘ï¼šç‚¹å‡»åŸå­æ˜¾ç¤ºé…ä½æ•° ---
        function onMouseClick(event) {
            // è®¡ç®—é¼ æ ‡ä½ç½®
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // æ£€æµ‹äº¤å‰
            if (!rootGroup) return;

            const intersects = raycaster.intersectObjects(rootGroup.children, true);

            if (intersects.length > 0) {
                // æ‰¾åˆ°ç¬¬ä¸€ä¸ªæ˜¯åŸå­çš„å¯¹è±¡
                let target = null;
                for(let hit of intersects) {
                     let obj = hit.object;
                     while(obj && obj !== rootGroup) {
                         if(obj.userData && obj.userData.index !== undefined) {
                             target = obj;
                             break;
                         }
                         obj = obj.parent;
                     }
                     if(target) break;
                }

                if (target) {
                    const atomIndex = target.userData.index;
                    const atomData = currentStructureData.atoms[atomIndex];
                    
                    // å†°æ™¶ä½“ç‰¹æ®Šå¤„ç†ï¼šåªèƒ½ç‚¹å‡»æ°§åŸå­ (ç”¨æˆ·è¦æ±‚ï¼šå†°æ™¶èƒä¸­åªèƒ½ç‚¹å‡»æ°§åŸå­ï¼Œæ˜¾ç¤ºé‚»è¿‘çš„4ä¸ªæ°§åŸå­)
                    if (currentStructureData.id === 'ice' && atomData.el === 'H') {
                        return; // å¿½ç•¥ç‚¹å‡» H
                    }

                    // äº¤äº’ä¼˜åŒ–ï¼šå†æ¬¡ç‚¹å‡»å·²ç‚¹äº®åŸå­æ—¶å–æ¶ˆé«˜äº®
                    // å¯¹äºåˆ†å­æ™¶ä½“ï¼Œå¦‚æœç‚¹å‡»çš„æ˜¯åŒä¸€ä¸ªåˆ†å­ï¼Œä¹Ÿè§†ä¸ºå–æ¶ˆ
                    let isSameSelection = false;
                    
                    if (state.selectedAtom) {
                        if (currentStructureData.type === 'molecular' && atomData.moleculeId !== undefined) {
                            // æ£€æŸ¥æ˜¯å¦æ˜¯åŒä¸€ä¸ªåˆ†å­
                            const selectedIndex = state.selectedAtom.userData.index;
                            const selectedData = currentStructureData.atoms[selectedIndex];
                            if (selectedData.moleculeId === atomData.moleculeId) {
                                isSameSelection = true;
                            }
                        } else {
                            // åŸå­æ™¶ä½“/ç¦»å­æ™¶ä½“/é‡‘å±æ™¶ä½“
                            if (state.selectedAtom.userData.index === atomIndex) {
                                isSameSelection = true;
                            }
                        }
                    }

                    if (isSameSelection) {
                        clearHighlights();
                    } else {
                        // åˆ†å­æ™¶ä½“é€»è¾‘ vs åŸå­é€»è¾‘
                        if (currentStructureData.type === 'molecular' && atomData.moleculeId !== undefined) {
                            highlightMoleculeNeighbors(target);
                        } else {
                            highlightNeighbors(target);
                        }
                    }
                } else {
                    clearHighlights();
                }
            } else {
                // ç‚¹å‡»ç©ºç™½å¤„æ¸…é™¤é«˜äº®
                clearHighlights();
            }
        }

        function clearHighlights() {
            // æ¸…é™¤çŠ¶æ€
            state.selectedAtom = null;

            // æ¢å¤æ‰€æœ‰åŸå­çš„æè´¨ (å–æ¶ˆæš—åŒ–)
            restoreMaterials();

            // æ¸…é™¤å¹½çµåŸå­å’Œè¿çº¿ (éƒ½åœ¨ ghostGroup ä¸­)
            while(ghostGroup.children.length > 0) {
                const child = ghostGroup.children[0];
                if(child.geometry) child.geometry.dispose();
                if(child.material) child.material.dispose();
                // å¦‚æœæ˜¯ Sprite (æ–‡å­—)ï¼Œé‡Šæ”¾ texture
                if(child.material && child.material.map) child.material.map.dispose();
                ghostGroup.remove(child);
            }
            
            // æ¸…é™¤æ‰€æœ‰åŸå­çš„å…‰æ™• (Halo)
            if(rootGroup) {
                rootGroup.traverse(obj => {
                    // ç§»é™¤åä¸º 'halo' çš„å­å¯¹è±¡
                    const halos = obj.children.filter(c => c.name === 'halo');
                    halos.forEach(h => {
                        if(h.geometry) h.geometry.dispose();
                        if(h.material) {
                            if(h.material.map) h.material.map.dispose(); // Dispose texture if sprite
                            h.material.dispose();
                        }
                        obj.remove(h);
                    });
                });
            }

            document.getElementById('cn-display').style.display = 'none';
        }

        // è¾…åŠ©ï¼šæš—åŒ–éæ´»è·ƒåŸå­
        function dimNonActiveAtoms(activeIndices) {
            // å¦‚æœç”¨æˆ·å…³é—­äº†æš—åŒ–åŠŸèƒ½ï¼Œç›´æ¥è¿”å› (ä¿æŒå…¨äº®)
            if (!state.enableDimming) return;

            rootGroup.traverse(obj => {
                // æ£€æŸ¥å¯¹è±¡æ˜¯å¦ä¸ºåŸå­ (å¸¦æœ‰ index)
                if (obj.userData && obj.userData.index !== undefined) {
                    const idx = obj.userData.index;
                    const isActive = activeIndices.has(idx);
                    
                    const applyToMesh = (mesh) => {
                         if (!mesh.isMesh) return;
                         // è·³è¿‡å…‰æ™• (halo)
                         if (mesh.name === 'halo') return;

                         if (!mesh.userData.originalMaterial) {
                             mesh.userData.originalMaterial = mesh.material;
                         }
                         
                         if (isActive) {
                            // æ´»è·ƒåŸå­ï¼šå¢å¼ºäº®åº¦ (å‘å…‰)
                            if (mesh.material === mesh.userData.originalMaterial) {
                                const bright = mesh.material.clone();
                                bright.emissive = mesh.material.color;
                                bright.emissiveIntensity = 0.6; // å¢åŠ è‡ªå‘å…‰
                                bright.roughness = 0.2; // å¢åŠ å…‰æ³½
                                mesh.material = bright;
                            }
                        } else {
                             // éæ´»è·ƒåŸå­ï¼šæš—åŒ–
                             if (mesh.material === mesh.userData.originalMaterial) {
                                 const dimmed = mesh.material.clone();
                                 dimmed.transparent = true;
                                 dimmed.opacity = 0.1; // æä½ä¸é€æ˜åº¦
                                 dimmed.roughness = 1.0; // å‡å°‘åå…‰
                                 dimmed.metalness = 0.0;
                                 mesh.material = dimmed;
                             }
                         }
                    };

                    if (obj.isMesh) {
                        applyToMesh(obj);
                    }
                    if (obj.children) {
                        obj.children.forEach(child => {
                            applyToMesh(child);
                        });
                    }
                }
            });
        }

        // è¾…åŠ©ï¼šæ¢å¤æ‰€æœ‰åŸå­æè´¨
        function restoreMaterials() {
             rootGroup.traverse(obj => {
                 const restore = (mesh) => {
                     if (mesh.userData && mesh.userData.originalMaterial) {
                         mesh.material.dispose(); // é‡Šæ”¾å…‹éš†çš„æè´¨
                         mesh.material = mesh.userData.originalMaterial;
                         delete mesh.userData.originalMaterial;
                     }
                 };
                 
                 if (obj.isMesh) restore(obj);
                 if (obj.children) {
                     obj.children.forEach(child => {
                         if (child.isMesh) restore(child);
                     });
                 }
             });
        }

        function highlightMoleculeNeighbors(targetLOD) {
            clearHighlights();
            state.selectedAtom = targetLOD;
            
            const atomIndex = targetLOD.userData.index;
            const originalData = currentStructureData;
            const targetAtom = originalData.atoms[atomIndex];
            const targetMolId = targetAtom.moleculeId;
            
            if (targetMolId === undefined) return;

            // 1. é«˜äº®é€‰ä¸­åˆ†å­çš„æ‰€æœ‰åŸå­
            const molAtomsIndices = [];
            originalData.atoms.forEach((a, idx) => {
                if (a.moleculeId === targetMolId) molAtomsIndices.push(idx);
            });

            molAtomsIndices.forEach(idx => {
                rootGroup.traverse(obj => {
                    if (obj.userData && obj.userData.index === idx) {
                        const color = CONFIG.colors[originalData.atoms[idx].el] || 0xffffff;
                        highlightAtom(obj, color);
                    }
                });
            });

            // 2. è®¡ç®—é€‰ä¸­åˆ†å­çš„è´¨å¿ƒ (COM)
            let comX=0, comY=0, comZ=0;
            molAtomsIndices.forEach(idx => {
                comX += originalData.atoms[idx].x;
                comY += originalData.atoms[idx].y;
                comZ += originalData.atoms[idx].z;
            });
            comX /= molAtomsIndices.length;
            comY /= molAtomsIndices.length;
            comZ /= molAtomsIndices.length;

            // 3. æœç´¢é‚»è¿‘åˆ†å­ (3x3x3 èŒƒå›´)
            const uniqueMolIds = [...new Set(originalData.atoms.map(a => a.moleculeId))].filter(id => id !== undefined);
            const candidates = [];
            const visited = new Set();
            
            const cell = originalData.cell;
            const vectors = [];
            if (cell.type === 'hexagonal') {
                const c = cell.c || 1.633;
                vectors.push({x: 1, y: 0, z: 0});
                vectors.push({x: -0.5, y: 0.866, z: 0});
                vectors.push({x: 0, y: 0, z: c});
            } else if (cell.type === 'orthorhombic') {
                vectors.push({x: cell.a, y: 0, z: 0});
                vectors.push({x: 0, y: cell.b, z: 0});
                vectors.push({x: 0, y: 0, z: cell.c});
            } else {
                vectors.push({x: 1, y: 0, z: 0});
                vectors.push({x: 0, y: 1, z: 0});
                vectors.push({x: 0, y: 0, z: 1});
            }
            
            for(let i=-1; i<=1; i++) {
                for(let j=-1; j<=1; j++) {
                    for(let k=-1; k<=1; k++) {
                        const shiftX = i*vectors[0].x + j*vectors[1].x + k*vectors[2].x;
                        const shiftY = i*vectors[0].y + j*vectors[1].y + k*vectors[2].y;
                        const shiftZ = i*vectors[0].z + j*vectors[1].z + k*vectors[2].z;
                        
                        uniqueMolIds.forEach(mid => {
                            if (i===0 && j===0 && k===0 && mid === targetMolId) return;
                            
                            // è®¡ç®—å€™é€‰åˆ†å­çš„è´¨å¿ƒ
                            const atomsOfMol = originalData.atoms.filter(a => a.moleculeId === mid);
                            let cx=0, cy=0, cz=0;
                            atomsOfMol.forEach(a => {
                                cx += a.x;
                                cy += a.y;
                                cz += a.z;
                            });
                            cx /= atomsOfMol.length;
                            cy /= atomsOfMol.length;
                            cz /= atomsOfMol.length;
                            
                            const pcx = cx + shiftX;
                            const pcy = cy + shiftY;
                            const pcz = cz + shiftZ;
                            
                            // å»é‡
                            const key = `${pcx.toFixed(3)},${pcy.toFixed(3)},${pcz.toFixed(3)}`;
                            if(visited.has(key)) return;
                            visited.add(key);

                            const d = Math.sqrt((pcx-comX)**2 + (pcy-comY)**2 + (pcz-comZ)**2);
                            
                            candidates.push({
                                d: d,
                                mid: mid,
                                atoms: atomsOfMol,
                                shift: {x: shiftX, y: shiftY, z: shiftZ},
                                center: {x: pcx, y: pcy, z: pcz}, // åˆ†å­ä¸­å¿ƒ
                                isOriginal: (i===0 && j===0 && k===0)
                            });
                        });
                    }
                }
            }
            
            let minDist = Infinity;
            candidates.forEach(c => { if(c.d < minDist) minDist = c.d; });
            
            let neighbors = [];
            if (originalData.id === 'i2' || originalData.id === 'co2') {
                 // ç¢˜/å¹²å†°æ™¶ä½“ç‰¹æ®Šå¤„ç†ï¼šç”±äºæ™¶èƒè¢«æ‹‰ä¼¸æˆ–ä¸ºäº†ç¬¦åˆé…ä½è§„åˆ™
                 // æˆ‘ä»¬ç›´æ¥é€‰å–è·ç¦»æœ€è¿‘çš„ 12 ä¸ªåˆ†å­
                 candidates.sort((a,b) => a.d - b.d);
                 neighbors = candidates.slice(0, 12);
            } else {
                 // æ ‡å‡†é€»è¾‘ï¼šé€‰å–è·ç¦»æœ€è¿‘çš„ä¸€å±‚åŸå­/åˆ†å­ (å…è®¸å¾®å°è¯¯å·®)
                 neighbors = candidates.filter(c => c.d >= minDist - 0.05 && c.d <= minDist + 0.05);
            }
            
            const cn = neighbors.length;
            
            // 4. æ”¶é›†æ´»è·ƒåŸå­ç´¢å¼•å¹¶æ‰§è¡Œæš—åŒ–
            const activeIndices = new Set();
            // æ·»åŠ ç›®æ ‡åˆ†å­çš„æ‰€æœ‰åŸå­
            molAtomsIndices.forEach(idx => activeIndices.add(idx));
            // æ·»åŠ æ™¶èƒå†…é‚»å±…åˆ†å­çš„æ‰€æœ‰åŸå­
            neighbors.forEach(nb => {
                if (nb.isOriginal) {
                    nb.atoms.forEach(atom => {
                        const idx = originalData.atoms.indexOf(atom);
                        if (idx !== -1) activeIndices.add(idx);
                    });
                }
            });
            dimNonActiveAtoms(activeIndices);

            // 5. é«˜äº®é‚»å±…å¹¶åˆ›å»ºå¹½çµåŸå­/è´¨ç‚¹
            // åœºæ™¯ä¸­å¿ƒåç§» (æ‰€æœ‰ createGhostAtom éœ€è¦å‡å»æ­¤åç§»)
            // æˆ‘ä»¬é€šè¿‡ targetLOD è·å–åç§»ï¼štargetLOD.position = targetAtom.pos - boxCenter
            // boxCenter = targetAtom.pos - targetLOD.position
            const boxCenter = new THREE.Vector3(
                targetAtom.x - targetLOD.position.x,
                targetAtom.y - targetLOD.position.y,
                targetAtom.z - targetLOD.position.z
            );

            neighbors.forEach(nb => {
                // ä½¿ç”¨è´¨ç‚¹ (Proxy) ä»£æ›¿å…¨åŸå­æ˜¾ç¤ºï¼Œé¿å…è§†è§‰æ··ä¹±
                const el = nb.atoms[0].el; // å–ç¬¬ä¸€ä¸ªåŸå­çš„é¢œè‰²ä½œä¸ºä»£è¡¨è‰²
                const color = CONFIG.colors[el] || 0xffffff;
                
                if (nb.isOriginal) {
                    // 1. æ™¶èƒå†…çš„åˆ†å­ï¼šä¿æŒåŸæ ·ï¼Œä»…é«˜äº®æ˜¾ç¤º (ä¸ä½¿ç”¨è´¨ç‚¹)
                    // éå†è¯¥åˆ†å­çš„æ‰€æœ‰åŸå­å¹¶é«˜äº®
                    nb.atoms.forEach(atom => {
                        // éœ€è¦æ‰¾åˆ°è¯¥åŸå­åœ¨ originalData.atoms ä¸­çš„ç´¢å¼•
                        const idx = originalData.atoms.indexOf(atom);
                        if (idx !== -1) {
                            // åœ¨åœºæ™¯ä¸­æ‰¾åˆ°å¯¹åº”çš„å¯¹è±¡
                            rootGroup.traverse(obj => {
                                if (obj.userData && obj.userData.index === idx) {
                                    highlightAtom(obj, color);
                                }
                            });
                        }
                    });
                } else {
                    // 2. æ™¶èƒå¤–çš„åˆ†å­ (æ–°å¢)ï¼šä½¿ç”¨è´¨ç‚¹è¡¨ç¤º
                    createMoleculeProxy(nb.center, boxCenter, color);
                }
                
                // ç»˜åˆ¶è¿çº¿ (ä¸­å¿ƒåˆ°ä¸­å¿ƒ) - å¯¹æ‰€æœ‰é‚»å±…éƒ½ç»˜åˆ¶ï¼Œä¿æŒè§†è§‰è¿è´¯æ€§
                createProxyLine({x: comX, y: comY, z: comZ}, nb.center, boxCenter);
            });
            
            createCNLabel(cn, targetLOD, targetAtom.el);
        }

        // è¾…åŠ©ï¼šåˆ›å»ºåˆ†å­è´¨ç‚¹ (Proxy)
        function createMoleculeProxy(pos, offset, colorHex) {
            // è´¨ç‚¹ä¸»ä½“ (å‘å…‰çƒä½“) - ç¼©å°å°ºå¯¸ (0.35 -> 0.12)
            const geometry = new THREE.SphereGeometry(0.12, 16, 16);
            const material = new THREE.MeshStandardMaterial({
                color: colorHex,
                emissive: colorHex,
                emissiveIntensity: 1.2, // å¤§å¹…å¢åŠ äº®åº¦ (0.6 -> 1.2)
                transparent: true,
                opacity: 1.0,
                roughness: 0.1,
                metalness: 0.2
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(pos.x - offset.x, pos.y - offset.y, pos.z - offset.z);
            mesh.name = 'ghost'; // ç¡®ä¿èƒ½è¢« clearHighlights æ¸…é™¤
            ghostGroup.add(mesh);
            
            // å¤–éƒ¨å…‰æ™• (Halo) - ç¼©å°å°ºå¯¸ (0.5 -> 0.25)
            const haloGeo = new THREE.SphereGeometry(0.25, 16, 16);
            const haloMat = new THREE.MeshBasicMaterial({
                color: colorHex,
                transparent: true,
                opacity: 0.6, // å¢åŠ å…‰æ™•ä¸é€æ˜åº¦
                depthWrite: false
            });
            const halo = new THREE.Mesh(haloGeo, haloMat);
            halo.name = 'halo';
            mesh.add(halo);
        }

        // è¾…åŠ©ï¼šåˆ›å»ºåˆ†å­é—´è¿çº¿
        function createProxyLine(start, end, offset) {
             const points = [];
             points.push(new THREE.Vector3(start.x - offset.x, start.y - offset.y, start.z - offset.z));
             points.push(new THREE.Vector3(end.x - offset.x, end.y - offset.y, end.z - offset.z));
             
             const geometry = new THREE.BufferGeometry().setFromPoints(points);
             // è™šçº¿æè´¨åœ¨ LineBasicMaterial ä¸­ä¸ç›´æ¥æ”¯æŒ dashï¼Œéœ€è¦ computeLineDistances å’Œ LineDashedMaterial
             // è¿™é‡Œå…ˆç”¨åŠé€æ˜å®çº¿ï¼Œç®€æ´ä¸ºä¸»
             const material = new THREE.LineBasicMaterial({ 
                 color: 0x00ffff, 
                 transparent: true, 
                 opacity: 0.3,
                 linewidth: 1
             });
             const line = new THREE.Line(geometry, material);
             line.name = 'ghost';
             ghostGroup.add(line);
        }

        function highlightNeighbors(targetLOD) {
            clearHighlights();
            state.selectedAtom = targetLOD; // è®°å½•é€‰ä¸­çŠ¶æ€
            
            const atomIndex = targetLOD.userData.index;
            const originalData = currentStructureData;
            if(!originalData) return;

            const targetAtom = originalData.atoms[atomIndex];
            const cell = originalData.cell;

            // 1. ç¡®å®šæ™¶æ ¼çŸ¢é‡ (ç”¨äº 3x3x3 æœç´¢)
            const vectors = [];
            if (cell.type === 'hexagonal') {
                const c = cell.c || 1.633;
                vectors.push({x: 1, y: 0, z: 0}); // a
                vectors.push({x: -0.5, y: 0.866, z: 0}); // b
                vectors.push({x: 0, y: 0, z: c}); // c
            } else if (cell.type === 'orthorhombic') {
                vectors.push({x: cell.a, y: 0, z: 0});
                vectors.push({x: 0, y: cell.b, z: 0});
                vectors.push({x: 0, y: 0, z: cell.c});
            } else {
                vectors.push({x: 1, y: 0, z: 0});
                vectors.push({x: 0, y: 1, z: 0});
                vectors.push({x: 0, y: 0, z: 1});
            }
            
            // 2. æœç´¢ 3x3x3 èŒƒå›´å†…çš„å€™é€‰é‚»å±…
            const candidates = [];
            const minStart = 0.1; // æœ€å°è·ç¦»é˜ˆå€¼ (æ’é™¤é‡åˆç‚¹)
            const visited = new Set(); // ç”¨äºå»é‡ (åæ ‡ key)

            originalData.atoms.forEach((atom, idx) => {
                for(let i=-1; i<=1; i++) {
                    for(let j=-1; j<=1; j++) {
                        for(let k=-1; k<=1; k++) {
                            // è®¡ç®—é•œåƒä½ç½®
                            const shiftX = i*vectors[0].x + j*vectors[1].x + k*vectors[2].x;
                            const shiftY = i*vectors[0].y + j*vectors[1].y + k*vectors[2].y;
                            const shiftZ = i*vectors[0].z + j*vectors[1].z + k*vectors[2].z;
                            
                            const px = atom.x + shiftX;
                            const py = atom.y + shiftY;
                            const pz = atom.z + shiftZ;
                            
                            // æ’é™¤è‡ªå·±
                            if(idx === atomIndex && i===0 && j===0 && k===0) continue;
                            
                            const d = Math.sqrt(
                                (px - targetAtom.x)**2 + 
                                (py - targetAtom.y)**2 + 
                                (pz - targetAtom.z)**2
                            );
                            
                            if (d > minStart) {
                                // å»é‡æ£€æŸ¥ (ä¿ç•™3ä½å°æ•°ä½œä¸ºkey)
                                const key = `${px.toFixed(3)},${py.toFixed(3)},${pz.toFixed(3)},${atom.el}`;
                                if(!visited.has(key)) {
                                    visited.add(key);
                                    candidates.push({
                                        d: d,
                                        x: px, y: py, z: pz,
                                        el: atom.el,
                                        isOriginal: (i===0 && j===0 && k===0),
                                        originalIndex: idx
                                    });
                                }
                            }
                        }
                    }
                }
            });

            // 3. åº”ç”¨é…ä½è§„åˆ™ç­›é€‰
            // åˆ¤æ–­æ˜¯å¦ä¸ºå•è´¨ (æ‰€æœ‰åŸå­å…ƒç´ ç›¸åŒ)
            const isSingleElement = originalData.atoms.every(a => a.el === originalData.atoms[0].el);
            
            let finalNeighbors = [];
            
            if (isSingleElement) {
                // å•è´¨è§„åˆ™ï¼šæ‰¾æœ€è¿‘çš„ç­‰è·åŸå­ (è¯¯å·®èŒƒå›´ Â±0.05Ã…)
                let minDist = Infinity;
                candidates.forEach(c => { if(c.d < minDist) minDist = c.d; });
                finalNeighbors = candidates.filter(c => c.d >= minDist - 0.05 && c.d <= minDist + 0.05);
            } else {
                // åŒ–åˆç‰©è§„åˆ™ï¼šæ”¯æŒå¤šé‡é…ä½ (å¦‚ CaTiO3 ä¸­ O é…ä½ 2Ti + 4Ca)
                // ç­–ç•¥ï¼šå¯¹äºæ¯ç§"ä¸åŒ"çš„å…ƒç´ ç±»å‹ï¼Œåˆ†åˆ«å¯»æ‰¾å…¶æœ€è¿‘é‚»
                
                const atomTypes = [...new Set(originalData.atoms.map(a => a.el))];
                const targetType = targetAtom.el;

                atomTypes.forEach(type => {
                    // 1. å†°æ™¶ä½“ç‰¹æ®Šå¤„ç†ï¼šåªæ‰¾ O-O é…ä½ (å¿½ç•¥ H)
                    if (originalData.id === 'ice') {
                        if (type !== 'O') return;
                    } else {
                        // 2. ä¸€èˆ¬åŒ–åˆç‰©é€»è¾‘ï¼š
                        
                        // è§„åˆ™ A: æ’é™¤åŒç§å…ƒç´  (é™¤éç‰¹æ®Šéœ€æ±‚)
                        if (type === targetType) return;

                        // è§„åˆ™ B: ç”µè·/ä»·æ€è§„åˆ™ (Charge Rule)
                        // ä»…å…è®¸å¼‚æ€§ç”µè·é…ä½ (é˜³ç¦»å­æ‰¾é˜´ç¦»å­ï¼Œé˜´ç¦»å­æ‰¾é˜³ç¦»å­)
                        // å¦‚æœç”µè·æœªå®šä¹‰æˆ–ä¸º0 (å¦‚é‡‘å±/å…±ä»·)ï¼Œåˆ™ä¸åº”ç”¨æ­¤è§„åˆ™ (é€€åŒ–ä¸ºè·ç¦»è§„åˆ™)
                        const q1 = CONFIG.charges[targetType] || 0;
                        const q2 = CONFIG.charges[type] || 0;
                        
                        if (q1 !== 0 && q2 !== 0) {
                             // å¦‚æœç¬¦å·ç›¸åŒ (åŒä¸ºæ­£æˆ–åŒä¸ºè´Ÿ)ï¼Œåˆ™äº’ç›¸æ’æ–¥ï¼Œä¸è®¡å…¥é…ä½
                             if (Math.sign(q1) === Math.sign(q2)) return;
                        }
                    }

                    // æ‰¾åˆ°è¯¥ç±»å‹åŸå­çš„æœ€è¿‘è·ç¦»
                    const typeCandidates = candidates.filter(c => c.el === type);
                    if (typeCandidates.length === 0) return;

                    let typeMin = Infinity;
                    typeCandidates.forEach(c => { if(c.d < typeMin) typeMin = c.d; });

                    // ç­›é€‰è¯¥ç±»å‹ä¸­ç¬¦åˆæœ€è¿‘è·ç¦»çš„åŸå­
                    const typeNeighbors = typeCandidates.filter(c => c.d >= typeMin - 0.05 && c.d <= typeMin + 0.05);
                    finalNeighbors.push(...typeNeighbors);
                });
            }
            
            // 4. æ”¶é›†æ´»è·ƒåŸå­ç´¢å¼•å¹¶æ‰§è¡Œæš—åŒ–
            const activeIndices = new Set();
            activeIndices.add(atomIndex); // è‡ªèº«
            finalNeighbors.forEach(nb => {
                if (nb.isOriginal) {
                    activeIndices.add(nb.originalIndex); // æ™¶èƒå†…é‚»å±…
                }
            });
            dimNonActiveAtoms(activeIndices);

            // 5. æ˜¾ç¤ºä¸é«˜äº®
            const cn = finalNeighbors.length;
            
            // é«˜äº®è‡ªèº« (å…‰æ™•)
            const selfColor = CONFIG.colors[targetAtom.el] || 0xffffff;
            highlightAtom(targetLOD, selfColor);

            // è®¡ç®— center åç§» (ç”¨äº createGhostAtom)
            const center = new THREE.Vector3();
            center.x = targetAtom.x - targetLOD.position.x;
            center.y = targetAtom.y - targetLOD.position.y;
            center.z = targetAtom.z - targetLOD.position.z;

            finalNeighbors.forEach(nb => {
                const nbColor = CONFIG.colors[nb.el] || 0xffffff;
                
                if(nb.isOriginal) {
                    // å°è¯•åœ¨åœºæ™¯ä¸­æ‰¾åˆ°å¯¹åº”åŸå­å¹¶é«˜äº®
                    let found = false;
                    rootGroup.traverse(obj => {
                        if(obj.userData && obj.userData.index === nb.originalIndex) {
                            highlightAtom(obj, nbColor);
                            found = true;
                        }
                    });
                    if(!found) createGhostAtom(nb, center, true);
                } else {
                    createGhostAtom(nb, center, true);
                }
                
                // ç»˜åˆ¶è¿çº¿
                const start = targetLOD.position.clone(); 
                const end = new THREE.Vector3(nb.x - center.x, nb.y - center.y, nb.z - center.z);
                
                const lineGeo = new THREE.BufferGeometry().setFromPoints([start, end]);
                const lineMat = new THREE.LineBasicMaterial({ 
                    color: 0x00ffff, // é’è‰²
                    transparent: true, 
                    opacity: 0.4,
                    depthTest: false 
                });
                const line = new THREE.Line(lineGeo, lineMat);
                ghostGroup.add(line);
            });
            
            // 5. åŠ¨æ€ CN æ˜¾ç¤º (Follow Atom)
            createCNLabel(cn, targetLOD, targetAtom.el);
        }

        // è§†è§‰ä¼˜åŒ–ï¼šä½¿ç”¨åŠé€æ˜å…‰æ™•æ›¿ä»£æ”¹å˜æè´¨
        function highlightAtom(lodObj, colorHex) {
            // æ£€æŸ¥æ˜¯å¦å·²æœ‰å…‰æ™•ï¼Œé¿å…é‡å¤æ·»åŠ 
            if (lodObj.children.some(c => c.name === 'halo')) return;

            const radius = lodObj.scale.x; // è·å–åŸå­åŠå¾„ (LOD æ ¹èŠ‚ç‚¹è¢«ç¼©æ”¾è¿‡)
            // åˆ›å»ºå…‰æ™•å‡ ä½•ä½“ (æ¯”åŸå­ç¨å¤§)
            const haloGeo = new THREE.SphereGeometry(1.4, 16, 16); 
            // ä¸ºä»€ä¹ˆæ˜¯ 1.4? åŸºç¡€ SphereGeometry åŠå¾„ä¸º 1ï¼ŒlodObj.scale å·²ç»æ˜¯åŸå­åŠå¾„
            // ä½†è¿™é‡Œæˆ‘ä»¬æ˜¯æŠŠ halo åŠ ä¸º lodObj çš„å­å¯¹è±¡ï¼Œæ‰€ä»¥ halo ä¼šç»§æ‰¿ lodObj çš„ scale
            // æ‰€ä»¥ halo çš„å®é™…åŠå¾„ = 1.4 * lodObj.scale
            
            const haloMat = new THREE.MeshBasicMaterial({
                color: colorHex,
                transparent: true,
                opacity: 0.4,
                side: THREE.FrontSide,
                depthWrite: false // ä¸å†™å…¥æ·±åº¦ç¼“å†²åŒºï¼Œé¿å…é®æŒ¡å†…éƒ¨åŸå­
            });
            
            const halo = new THREE.Mesh(haloGeo, haloMat);
            halo.name = 'halo';
            lodObj.add(halo);
        }

        function createGhostAtom(data, center, isHighlight = false) {
            // åˆ›å»ºåŸå­å®ä½“ (åŠé€æ˜)
            const geometry = new THREE.SphereGeometry(1, 16, 16);
            const color = CONFIG.colors[data.el] || 0xffffff;
            const material = new THREE.MeshStandardMaterial({
                color: color,
                transparent: true,
                opacity: 0.3,
                roughness: 0.5,
                metalness: 0.5
            });
            
            // å¦‚æœæ˜¯é«˜äº®çŠ¶æ€ï¼Œå¢å¼ºäº®åº¦
            if (isHighlight) {
                material.opacity = 0.8;
                material.emissive = color;
                material.emissiveIntensity = 0.5;
            }

            const mesh = new THREE.Mesh(geometry, material);
            
            // è®¾ç½®ä½ç½®
            mesh.position.set(data.x - center.x, data.y - center.y, data.z - center.z);
            
            // è®¾ç½®å¤§å°
            const radius = CONFIG.radii[data.el] || CONFIG.atomScale;
            mesh.scale.set(radius, radius, radius);
            
            // å¦‚æœæ˜¯é«˜äº®çŠ¶æ€ï¼Œæ·»åŠ å…‰æ™•
            if (isHighlight) {
                const haloGeo = new THREE.SphereGeometry(1.4, 16, 16);
                const haloMat = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.5, // å¢åŠ å…‰æ™•ä¸é€æ˜åº¦
                    depthWrite: false
                });
                const halo = new THREE.Mesh(haloGeo, haloMat);
                mesh.add(halo);
            }
            
            ghostGroup.add(mesh);
        }

        // åŠ¨æ€ CN æ ‡ç­¾ (ç¾åŒ–ç‰ˆ)
        function createCNLabel(cnValue, targetObj, element) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512; // æé«˜åˆ†è¾¨ç‡
            canvas.height = 256;
            
            // ç»˜åˆ¶åœ†è§’çŸ©å½¢èƒŒæ™¯
            const x = 20, y = 20, w = 472, h = 216, r = 40;
            context.beginPath();
            context.moveTo(x+r, y);
            context.arcTo(x+w, y, x+w, y+h, r);
            context.arcTo(x+w, y+h, x, y+h, r);
            context.arcTo(x, y+h, x, y, r);
            context.arcTo(x, y, x+w, y, r);
            context.closePath();
            
            // æ¸å˜å¡«å……
            const gradient = context.createLinearGradient(0, 0, 0, 256);
            gradient.addColorStop(0, 'rgba(0, 40, 80, 0.85)');
            gradient.addColorStop(1, 'rgba(0, 20, 40, 0.95)');
            context.fillStyle = gradient;
            context.fill();
            
            // è¾¹æ¡†
            context.lineWidth = 8;
            context.strokeStyle = 'rgba(0, 243, 255, 0.8)'; // é’è‰²è¾¹æ¡†
            context.stroke();
            
            // ç»˜åˆ¶æ–‡å­— "CN=X"
            context.font = 'bold 140px "Segoe UI", Arial, sans-serif';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            // æ–‡å­—é˜´å½±
            context.shadowColor = 'rgba(0, 243, 255, 0.8)';
            context.shadowBlur = 20;
            context.fillStyle = '#ffffff';
            
            const text = "CN=" + cnValue;
            context.fillText(text, 256, 128);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ 
                map: texture, 
                transparent: true,
                depthTest: false // ç¡®ä¿æ˜¾ç¤ºåœ¨æœ€å‰ (æˆ–è€…æ ¹æ®éœ€æ±‚å¼€å¯)
            });
            // å¼€å¯ depthTest: false ä¼šå¯¼è‡´é€è¿‡æ¨¡å‹çœ‹åˆ°æ ‡ç­¾ï¼Œè¿™å¯èƒ½ä¸æ˜¯æƒ³è¦çš„ã€‚
            // è¿˜æ˜¯å¼€å¯ depthTest æ¯”è¾ƒçœŸå®ã€‚
            spriteMaterial.depthTest = true; 

            const sprite = new THREE.Sprite(spriteMaterial);
            
            // ç¼©æ”¾è®¾ç½®
            const scale = 5.0; 
            sprite.scale.set(scale, scale * 0.5, 1);
            
            // ä½ç½®è®¾ç½®
            sprite.position.set(0, 2.8, 0); // ç¨å¾®è°ƒé«˜ä¸€ç‚¹
            sprite.name = 'halo'; // ç»Ÿä¸€ç®¡ç†
            
            targetObj.add(sprite);
        }

        function animate() {
            frameId = requestAnimationFrame(animate);
            
            const time = Date.now();

            // Breathing Box Effect
            if(rootGroup) {
                const timeSec = time * 0.001;
                rootGroup.traverse(child => {
                    if(child.name === 'unitBox') {
                        // Pulse opacity between 0.1 and 0.4
                        child.material.opacity = 0.25 + Math.sin(time * 0.003) * 0.15;
                    }
                    
                    // å¤„ç†åŸå­æŒ¯åŠ¨åŠ¨ç”»
                    if(child.userData && child.userData.animData && !state.paused) {
                         const data = child.userData.animData;
                         if(data.type === 'oscillation') {
                              // æ¨¡æ‹Ÿ O-H ä¼¸ç¼©æŒ¯åŠ¨ (3000 cm^-1)
                              // è°ƒæ•´é¢‘ç‡ä¸º 1Hz (2 * PI â‰ˆ 6.28)
                              const freq = 6.28; 
                              
                              // å½’ä¸€åŒ–æ–¹å‘å‘é‡å¹¶è·å–é”®é•¿
                              const len = Math.sqrt(data.dir.x**2 + data.dir.y**2 + data.dir.z**2);
                              
                              if (len > 0) {
                                 // æŒ¯å¹…è®¾ç½®ä¼˜åŒ–ï¼š
                                 // ç”¨æˆ·è¦æ±‚ï¼šæœ€è¿‘èŒƒå›´æ¥è§¦æ°§åŸå­è¡¨é¢ï¼Œæœ€è¿œèŒƒå›´æ¥è§¦å¦ä¸€ä¸ªæ°§åŸå­è¡¨é¢
                                 // æ­¤æ—¶HåŸå­ä»¥ä¸¤ä¸ªæ°§åŸå­çš„ä¸­ç‚¹ä¸ºå¹³è¡¡ä½ç½®è¿›è¡Œç®€è°æŒ¯åŠ¨
                                 
                                 const radiusO = CONFIG.radii.O || 0.18;
                                 const radiusH = CONFIG.radii.H || 0.08;
                                 
                                 // æœ€å°ä¸­å¿ƒé—´è· = æ°§åŸå­åŠå¾„ + æ°¢åŸå­åŠå¾„ (åˆšå¥½æ¥è§¦è¡¨é¢)
                                 const minCenterDist = radiusO + radiusH; 
                                 
                                 // æŒ¯å¹…è®¡ç®—ï¼š
                                 // æ•´ä¸ªå¯ç”¨ç©ºé—´é•¿åº¦ = len (O-Oè·ç¦»)
                                 // å•ä¾§å¯ç”¨ç©ºé—´ = len/2
                                 // å…è®¸çš„æœ€å¤§ä½ç§»(æŒ¯å¹…) = å•ä¾§ç©ºé—´ - æœ€å°æ¥è§¦è·ç¦»
                                 // è¿™æ ·åœ¨æå€¼ç‚¹æ—¶ï¼ŒHåŸå­è·ç¦»OåŸå­ä¸­å¿ƒæ­£å¥½æ˜¯ minCenterDist
                                 const maxAmp = (len / 2) - minCenterDist;
                                 const amp = Math.max(0, maxAmp);
                                 
                                 const offset = Math.sin(timeSec * freq + data.phase) * amp;
                                 
                                 const dx = (data.dir.x / len) * offset;
                                 const dy = (data.dir.y / len) * offset;
                                 const dz = (data.dir.z / len) * offset;
                                 
                                 child.position.set(
                                     child.userData.basePos.x + dx,
                                     child.userData.basePos.y + dy,
                                     child.userData.basePos.z + dz
                                 );
                              }
                          }
                    }

                    // å¤„ç†åŠ¨æ€é”® (æ›´æ–°ä½ç½®å’Œé¢œè‰²)
                    if(child.userData && child.userData.isDynamicBond && !state.paused) {
                         const start = child.userData.startLOD.position;
                         const end = child.userData.endLOD.position;
                         const dist = start.distanceTo(end);
                         
                         // Update transform
                         const mid = start.clone().add(end).multiplyScalar(0.5);
                         child.position.copy(mid);
                         
                         const radius = child.scale.x; // Keep existing radius
                         child.scale.set(radius, dist, radius);
                         child.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), end.clone().sub(start).normalize());
                         
                         // Color Switch Logic
                         // è·ç¦»é•¿çš„ä¸ºæ°¢é”®(è“è‰²)ï¼Œè·ç¦»çŸ­çš„ä¸ºå…±ä»·é”®(ç™½è‰²)
                         // é˜ˆå€¼ä½¿ç”¨åˆå§‹è·ç¦» (çº¦ä¸º O-O è·ç¦»çš„ä¸€åŠ)
                         const threshold = child.userData.threshold || 0.35; // é»˜è®¤ 0.35 å¦‚æœæ²¡è®¾ç½®
                         if(dist > threshold) {
                             child.material = child.userData.matHBond;
                         } else {
                             child.material = child.userData.matCovalent;
                         }
                    }
                });
            }
            
            // Demo Mode Logic
            if(state.demoMode && !state.paused && !state.isTransitioning) {
                controls.autoRotate = true;
                
                const now = Date.now();
                // ç¡®ä¿æ—¶é—´æˆ³å·²åˆå§‹åŒ–
                if (state.lastSwitchTime === 0) state.lastSwitchTime = now;
                if (state.lastDemoActionTime === 0) state.lastDemoActionTime = now;

                const timeSinceAction = now - state.lastDemoActionTime;
                
                // çŠ¶æ€æœºï¼šPhase 0 -> 1...N -> N+1 -> Next Structure
                if (state.demoPhase === 0) {
                    // Phase 0: åˆå§‹å…¨è§ˆå±•ç¤º (Whole View)
                    if (timeSinceAction > CONFIG.demoStayTime) {
                        state.demoPhase = 1;
                        state.lastDemoActionTime = now;
                        state.demoActionDone = false;
                    }
                } else if (state.demoPhase <= state.demoTargets.length) {
                    // Phase 1 to N: é…ä½é«˜äº®å±•ç¤º (Highlight Types)
                    
                    // æ‰§è¡Œé«˜äº®åŠ¨ä½œ (ä»…æ‰§è¡Œä¸€æ¬¡)
                    if (!state.demoActionDone) {
                        const targetIdx = state.demoTargets[state.demoPhase - 1];
                        triggerDemoHighlight(targetIdx);
                        state.demoActionDone = true;
                    }
                    
                    // ç­‰å¾…é«˜äº®å±•ç¤ºæ—¶é—´
                    if (timeSinceAction > CONFIG.demoHighlightTime) {
                        // æ¸…é™¤é«˜äº®å¹¶è¿›å…¥ä¸‹ä¸€é˜¶æ®µ
                        clearHighlights();
                        state.demoPhase++;
                        state.lastDemoActionTime = now;
                        state.demoActionDone = false;
                    }
                } else {
                    // Phase N+1: ç»“æŸå…¨è§ˆå±•ç¤º (End Whole View)
                    // ç¡®ä¿é«˜äº®å·²æ¸…é™¤ (ä¸Šä¸ªé˜¶æ®µç»“æŸæ—¶å·²æ¸…é™¤)
                    if (timeSinceAction > CONFIG.demoStayTime) {
                        nextStructure();
                        // nextStructure -> loadStructure ä¼šé‡ç½® demoPhase ä¸º 0
                    }
                }
            } else {
                controls.autoRotate = false;
            }

            controls.update();
            renderer.render(scene, camera);
        }

        let transitionInterval = null;
        let pendingGroup = null;

        // è¾…åŠ©ï¼šæ ¹æ®ç´¢å¼•æŸ¥æ‰¾åœºæ™¯ä¸­çš„åŸå­å¯¹è±¡
        function findAtomObjectByIndex(index) {
            let target = null;
            if (rootGroup) {
                rootGroup.traverse(obj => {
                    if (obj.userData && obj.userData.index === index) {
                        target = obj;
                    }
                });
            }
            return target;
        }

        // è¾…åŠ©ï¼šè§¦å‘æ¼”ç¤ºæ¨¡å¼çš„é«˜äº®
        function triggerDemoHighlight(atomIndex) {
            const target = findAtomObjectByIndex(atomIndex);
            if (!target) return;
            
            const atomData = currentStructureData.atoms[atomIndex];
            
            // å¤ç”¨ onMouseClick çš„åˆ†å‘é€»è¾‘
            if (currentStructureData.type === 'molecular' && atomData.moleculeId !== undefined) {
                highlightMoleculeNeighbors(target);
            } else {
                highlightNeighbors(target);
            }
        }

        // è¾…åŠ©ï¼šå‡†å¤‡æ¼”ç¤ºæ¨¡å¼çš„ç›®æ ‡åŸå­
        function prepareDemoTargets(data) {
            state.demoTargets = [];
            
            if (!data || !data.atoms) return;

            // ç‰¹æ®Šè§„åˆ™ï¼šå†°åªå±•ç¤ºæ°§åŸå­
            if (data.id === 'ice') {
                const oIndex = data.atoms.findIndex(a => a.el === 'O');
                if (oIndex !== -1) state.demoTargets.push(oIndex);
                return;
            }

            // ä¸€èˆ¬è§„åˆ™ï¼šæ¯ç§å…ƒç´ é€‰ä¸€ä¸ª
            const elements = new Set();
            data.atoms.forEach((atom, index) => {
                if (!elements.has(atom.el)) {
                    // å°½é‡é€‰æ‹©é è¿‘ä¸­å¿ƒçš„åŸå­ï¼Œè§†è§‰æ•ˆæœæ›´å¥½
                    // è¿™é‡Œç®€å•å¤„ç†ï¼šé€‰æ‹©è¯¥å…ƒç´ çš„ç¬¬ä¸€ä¸ªåŸå­
                    // ä¼˜åŒ–ï¼šå¦‚æœæ˜¯ç®€å•ç«‹æ–¹ç­‰ï¼Œç¬¬ä¸€ä¸ªåŸå­é€šå¸¸åœ¨é¡¶ç‚¹ (0,0,0)ï¼Œå¯èƒ½ä¸å¦‚ä½“å¿ƒæ¸…æ™°
                    // ä½†å¯¹äºè‡ªåŠ¨æ¼”ç¤ºï¼Œé¡¶ç‚¹ä¹Ÿå¯ä»¥ã€‚
                    
                    // å¦‚æœæ˜¯ NaCl (FCCå˜ä½“)ï¼Œé¡¶ç‚¹ Cl (0,0,0) å’Œ æ£±å¿ƒ Na (0.5,0,0)
                    // å¦‚æœæ˜¯ CsCl (SC+Body), Cl (0,0,0), Cs (0.5,0.5,0.5)
                    
                    elements.add(atom.el);
                    state.demoTargets.push(index);
                }
            });
            
            // æ’åºä¼˜åŒ–ï¼šé€šå¸¸é˜³ç¦»å­åœ¨å‰æˆ–é˜´ç¦»å­åœ¨å‰ï¼Ÿ
            // ä¿æŒåœ¨ atoms æ•°ç»„ä¸­çš„å‡ºç°é¡ºåºå³å¯
        }

        // --- æ ¸å¿ƒé€»è¾‘ï¼šåŠ è½½å¹¶æ¸²æŸ“æ™¶ä½“ç»“æ„ ---
        function loadStructure(index) {
            // å‚æ•°æ ¡éªŒï¼Œé˜²æ­¢è¶Šç•Œ
            if(index < 0 || index >= structures.length) index = 0;
            
            // ä¿®å¤ï¼šå¤„ç†å¿«é€Ÿåˆ‡æ¢æ—¶çš„ç«æ€æ¡ä»¶ (å¦‚æœä¸Šä¸€ä¸ªåŠ¨ç”»è¿˜æ²¡åšå®Œ)
            if(state.isTransitioning) {
                if(transitionInterval) clearInterval(transitionInterval);
                if(pendingGroup) {
                    scene.remove(pendingGroup);
                    // æ¸…ç†å‡ ä½•ä½“å’Œæè´¨ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼
                    pendingGroup.traverse(o => {
                        if(o.geometry) o.geometry.dispose();
                        if(o.material) o.material.dispose();
                    });
                }
                // é‡ç½®æ—§ç»„çš„çŠ¶æ€
                if(rootGroup) {
                    rootGroup.scale.set(1, 1, 1);
                }
                state.isTransitioning = false;
            }

            state.currentIndex = index;
            state.lastSwitchTime = Date.now();
            
            // é‡ç½®æ¼”ç¤ºæ¨¡å¼çŠ¶æ€
            state.demoPhase = 0;
            state.lastDemoActionTime = Date.now();
            state.demoActionDone = false;
            
            state.isTransitioning = true;

            // è·å–å½“å‰æ™¶ä½“çš„æ•°æ®
            const data = structures[index];
            // è°ƒç”¨ç”Ÿæˆå™¨ç”ŸæˆåŸå­å’Œé”®çš„æ•°æ®
            const geometry = data.generator();
            
            // å‡†å¤‡æ¼”ç¤ºç›®æ ‡
            // ä¿®æ­£ï¼šä¼ å…¥åŒ…å« atoms çš„ geometry å¯¹è±¡ï¼Œå¹¶åˆå¹¶åŸå§‹æ•°æ®ä»¥è·å– id ç­‰ä¿¡æ¯
            prepareDemoTargets({ ...data, ...geometry });
            
            // 1. æ›´æ–° UI (HUD å’Œ å¯¼èˆªæ )
            updateHUD(data);
            updateNav(index);

            // 2. åœºæ™¯åˆ‡æ¢é€»è¾‘
            // åŠ¨ç”»æ•ˆæœï¼šæ—§çš„ç¼©å°ï¼Œæ–°çš„æ”¾å¤§
            const oldGroup = rootGroup;
            const newGroup = new THREE.Group();
            pendingGroup = newGroup;
            
            // ä¿å­˜å½“å‰æ•°æ®ä¾›äº¤äº’ä½¿ç”¨
            currentStructureData = { ...data, ...geometry };

            // æ„å»ºæ–°çš„3Dåœºæ™¯
            buildScene(newGroup, geometry, data);
            newGroup.scale.set(0.01, 0.01, 0.01); // åˆå§‹å¤§å°è®¾ä¸ºæå°
            scene.add(newGroup);

            // æ‰§è¡Œè¿‡æ¸¡åŠ¨ç”»
            let progress = 0;
            transitionInterval = setInterval(() => {
                progress += 0.05; // åŠ¨ç”»é€Ÿåº¦
                if(progress >= 1) {
                    // åŠ¨ç”»ç»“æŸ
                    clearInterval(transitionInterval);
                    scene.remove(oldGroup);
                    // æ¸…ç†æ—§èµ„æº
                    if(oldGroup) {
                        oldGroup.traverse(o => {
                            if(o.geometry) o.geometry.dispose();
                            if(o.material) o.material.dispose();
                        });
                    }
                    rootGroup = newGroup;
                    state.isTransitioning = false;
                    pendingGroup = null;
                    transitionInterval = null;
                } else {
                    // ç¼“åŠ¨æ•ˆæœ (Ease out)
                    const scale = 1 - Math.pow(1 - progress, 3);
                    newGroup.scale.set(scale, scale, scale);
                    if(oldGroup) {
                        oldGroup.scale.set(1-scale, 1-scale, 1-scale);
                        oldGroup.rotation.y += 0.1; // æ—‹è½¬é€€å‡º
                    }
                }
            }, 16); // çº¦ 60fps
        }

        function buildScene(group, data, meta) {
            // è®¡ç®—ä¸­å¿ƒç‚¹ï¼Œç”¨äºå±…ä¸­æ˜¾ç¤º
            const box = new THREE.Box3();
            data.atoms.forEach(a => box.expandByPoint(new THREE.Vector3(a.x, a.y, a.z)));
            const center = new THREE.Vector3();
            box.getCenter(center);

            // ä¼˜åŒ–ï¼šå…±äº«å‡ ä½•ä½“å’Œæè´¨ (ä½¿ç”¨ LOD å¤šç»†èŠ‚å±‚æ¬¡æŠ€æœ¯)
            // é«˜æ¨¡ã€ä¸­æ¨¡ã€ä½æ¨¡
            const geoHigh = new THREE.SphereGeometry(1, 16, 12);
            const geoMed = new THREE.SphereGeometry(1, 8, 8);
            const geoLow = new THREE.SphereGeometry(1, 6, 5);
            
            // é”®çš„å‡ ä½•ä½“ï¼ˆåœ†æŸ±ï¼‰
            const bondGeo = new THREE.CylinderGeometry(1, 1, 1, 6); // å‡å°‘åˆ†æ®µæ•°ä»¥ä¼˜åŒ–æ€§èƒ½

            const materials = {};
            // è·å–æè´¨çš„ç¼“å­˜å‡½æ•°
            const getMaterial = (el) => {
                if(!materials[el]) {
                    const color = CONFIG.colors[el] || 0xffffff;
                    // ä½¿ç”¨ç‰©ç†æè´¨ï¼Œå¢åŠ è´¨æ„Ÿ
                    materials[el] = new THREE.MeshPhysicalMaterial({
                        color: color,
                        emissive: color,
                        emissiveIntensity: 0.5, // æé«˜è‡ªå‘å…‰å¼ºåº¦ (0.3 -> 0.5)
                        metalness: 0.3,
                        roughness: 0.2,
                        clearcoat: 1.0,
                        transparent: true,
                        opacity: 0.95 // ç¨å¾®å¢åŠ ä¸é€æ˜åº¦
                    });
                }
                return materials[el];
            };

            // æ¸²æŸ“åŸå­ (ä½¿ç”¨ LOD)
            data.atoms.forEach((a, idx) => {
                // è§„èŒƒåŒ–å…ƒç´ ç¬¦å· (å¦‚ 'na' -> 'Na')
                let el = a.el;
                if(el.length === 2) el = el.charAt(0).toUpperCase() + el.charAt(1).toLowerCase();
                else el = el.toUpperCase();

                const material = getMaterial(el);
                
                const lod = new THREE.LOD();
                
                // æ·»åŠ ä¸åŒè·ç¦»ä¸‹çš„ç»†èŠ‚çº§åˆ«
                const m1 = new THREE.Mesh(geoHigh, material);
                lod.addLevel(m1, 0);
                
                const m2 = new THREE.Mesh(geoMed, material);
                lod.addLevel(m2, 20);
                
                const m3 = new THREE.Mesh(geoLow, material);
                lod.addLevel(m3, 40);

                // è®¾ç½®åŸå­å¤§å°
                // ä¼˜å…ˆä½¿ç”¨æ•°æ®ä¸­çš„ radiusï¼Œå¦åˆ™æŸ¥æ‰¾ CONFIG.radiiï¼Œæœ€åä½¿ç”¨é»˜è®¤ atomScale
                const scale = a.radius || CONFIG.radii[el] || CONFIG.atomScale;
                lod.scale.set(scale, scale, scale);
                // è®¾ç½®ä½ç½® (å‡å»ä¸­å¿ƒç‚¹åç§»)
                lod.position.set(a.x - center.x, a.y - center.y, a.z - center.z);
                
                // å­˜å‚¨å…ƒæ•°æ®
                lod.userData = {
                    index: idx,
                    el: el,
                    originalPos: {x: a.x, y: a.y, z: a.z},
                    radius: scale
                };

                // å­˜å‚¨åŠ¨ç”»æ‰€éœ€çš„åŸºå‡†ä½ç½®å’Œæ•°æ®
                if(a.animData) {
                    lod.userData.animData = a.animData;
                    lod.userData.basePos = lod.position.clone();
                }

                // ä¿å­˜å¼•ç”¨ä¾›é”®ç”Ÿæˆä½¿ç”¨
                a.lodReference = lod;

                group.add(lod);
            });

            // æ¸²æŸ“åŒ–å­¦é”®
            data.bonds.forEach(b => {
                const start = new THREE.Vector3(b.start.x - center.x, b.start.y - center.y, b.start.z - center.z);
                const end = new THREE.Vector3(b.end.x - center.x, b.end.y - center.y, b.end.z - center.z);
                
                const distance = start.distanceTo(end);
                const position = start.clone().add(end).multiplyScalar(0.5);
                
                let material;
                let radius = CONFIG.bondRadius;

                if (b.type === 'hbond') {
                    // æ°¢é”®ï¼šä½¿ç”¨åŠé€æ˜æè´¨ï¼Œä¸”åŠ ç²—ï¼Œé¢œè‰²æ›´é²œè‰³
                    material = new THREE.MeshBasicMaterial({
                        color: 0x00ffff, // é’è‰²ï¼Œé«˜äº®æ˜¾ç¤º
                        transparent: true,
                        opacity: 0.8,    // æé«˜ä¸é€æ˜åº¦
                        blending: THREE.NormalBlending,
                        depthWrite: false // é¿å…æ·±åº¦é®æŒ¡é—®é¢˜
                    });
                    radius = CONFIG.bondRadius * 1.0; // é€‚å½“åŠ ç²—ï¼Œä½†ä¸è¶…è¿‡å…±ä»·é”®å¤ªå¤š
                    
                    // è™šçº¿æ•ˆæœ (é€šè¿‡çº¹ç†æˆ–ç®€å•çš„åˆ†æ®µå‡ ä½•ä½“æ¨¡æ‹Ÿï¼Œè¿™é‡Œç”¨è™šçº¿æè´¨æ¨¡æ‹Ÿæ¯”è¾ƒå¤æ‚ï¼Œæš‚ç”¨åŠé€æ˜å®çº¿è¡¨ç¤º)
                    // å¦‚æœéœ€è¦è™šçº¿ï¼Œå¯ä»¥ä½¿ç”¨ LineSegmentsï¼Œä½† Mesh æ›´å®¹æ˜“æ§åˆ¶ç²—ç»†
                } else {
                    // æ ‡å‡†å…±ä»·é”®ï¼šåŠé€æ˜ç™½è‰²
                    material = new THREE.MeshBasicMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.15,
                        blending: THREE.AdditiveBlending
                    });
                }

                const mesh = new THREE.Mesh(bondGeo, material);
                mesh.position.copy(position);
                mesh.scale.set(radius, distance, radius);
                // è®¡ç®—æ—‹è½¬ï¼Œä½¿åœ†æŸ±ä½“å¯¹é½ä¸¤ä¸ªåŸå­
                mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), end.clone().sub(start).normalize());
                
                // åŠ¨æ€é”®é€»è¾‘ï¼šå¦‚æœè¿æ¥äº†æŒ¯åŠ¨åŸå­ï¼Œæ ‡è®°ä¸ºåŠ¨æ€é”®
                if (b.start.lodReference && b.end.lodReference) {
                     const startLOD = b.start.lodReference;
                     const endLOD = b.end.lodReference;
                     if (startLOD.userData.animData || endLOD.userData.animData) {
                         mesh.userData.isDynamicBond = true;
                         mesh.userData.startLOD = startLOD;
                         mesh.userData.endLOD = endLOD;
                         
                         // è®¡ç®—åˆå§‹è·ç¦»ä½œä¸ºåˆ‡æ¢é˜ˆå€¼ (å› ä¸ºHåˆå§‹åœ¨O-Oä¸­ç‚¹)
                         // ç¨å¾®åŠ ä¸€ç‚¹å®¹å·®ï¼Œç¡®ä¿åˆå§‹çŠ¶æ€ä¸º covalent or transition
                         const initialDist = start.distanceTo(end);
                         // ä¹‹å‰è®¾ä¸º +0.05 å¤ªå¤§ï¼Œå¯¼è‡´æŒ¯åŠ¨å¹…åº¦(çº¦0.04)ä¸è¶³ä»¥è§¦å‘åˆ‡æ¢
                         // æ”¹ä¸ºæå°å€¼ï¼Œåªè¦åç¦»ä¸­ç‚¹å³åˆ‡æ¢
                         mesh.userData.threshold = initialDist + 0.001;

                         // é¢„åˆ›å»ºæè´¨ç”¨äºåˆ‡æ¢
                         mesh.userData.matCovalent = new THREE.MeshBasicMaterial({
                            color: 0xffffff,
                            transparent: true,
                            opacity: 0.25,
                            blending: THREE.AdditiveBlending
                        });
                        mesh.userData.matHBond = new THREE.MeshBasicMaterial({
                            color: 0x00ffff,
                            transparent: true,
                            opacity: 0.8,
                            blending: THREE.NormalBlending,
                            depthWrite: false
                        });
                     }
                }
                
                group.add(mesh);
            });
            
            // æ¸²æŸ“æ™¶èƒè¾¹æ¡†
            if (data.cell) {
                addUnitCellFrame(group, data.cell, center);
            }
        }

        function addUnitCellFrame(group, cell, center) {
            const mat = new THREE.LineBasicMaterial({ color: 0x000000 });
            let geometry;

            if (cell.type === 'hexagonal') { // å…­æ–¹æ™¶èƒ
                const a = cell.a || 1;
                const c = cell.c || 1.633;
                
                // ç»˜åˆ¶è±å½¢æŸ± (å…­æ–¹æ™¶èƒçš„ç®€å•åŸèƒ)
                const h = 0.866 * a; // sin(60) * a
                const p0 = new THREE.Vector3(0, 0, 0);
                const p1 = new THREE.Vector3(a, 0, 0);
                const p2 = new THREE.Vector3(0.5*a, h, 0);
                const p3 = new THREE.Vector3(-0.5*a, h, 0);
                
                const corners = [p0, p1, p2, p3];
                const pts = [];
                
                // Bottom
                pts.push(corners[0], corners[1]);
                pts.push(corners[1], corners[2]);
                pts.push(corners[2], corners[3]);
                pts.push(corners[3], corners[0]);
                
                // Top
                const top = corners.map(p => new THREE.Vector3(p.x, p.y, c));
                pts.push(top[0], top[1]);
                pts.push(top[1], top[2]);
                pts.push(top[2], top[3]);
                pts.push(top[3], top[0]);
                
                // Pillars
                pts.push(corners[0], top[0]);
                pts.push(corners[1], top[1]);
                pts.push(corners[2], top[2]);
                pts.push(corners[3], top[3]);
                
                geometry = new THREE.BufferGeometry().setFromPoints(pts);
                
                const line = new THREE.LineSegments(geometry, mat);
                line.position.set(-center.x, -center.y, -center.z);
                line.name = 'unitBox';
                group.add(line);
                
            } else {
                // ç«‹æ–¹ / æ­£äº¤ æ™¶èƒç›’å­
                const sx = (cell.a || 1);
                const sy = (cell.b || sx);
                const sz = (cell.c || sx);
                geometry = new THREE.BoxGeometry(sx, sy, sz);
                const edges = new THREE.EdgesGeometry(geometry);
                const line = new THREE.LineSegments(edges, mat);
                
                const framePos = new THREE.Vector3(sx/2, sy/2, sz/2);
                line.position.set(framePos.x - center.x, framePos.y - center.y, framePos.z - center.z);
                line.name = 'unitBox';
                group.add(line);
            }
        }

        // --- UI Logic ---
        function formatFormula(text) {
            // ä¿®å¤ï¼šç§»é™¤ margin-rightï¼Œè§£å†³æ•°å­—å’Œå­—æ¯é—´éš”è¿‡å¤§çš„é—®é¢˜
            return text.replace(/([a-zA-Z])(\d+)/g, '$1<sub>$2</sub>');
        }

        function initUI() {
            const nav = document.getElementById('nav-sidebar');
            let lastCat = '';
            
            structures.forEach((s, i) => {
                if(s.category !== lastCat) {
                    const cat = document.createElement('div');
                    cat.className = 'category-title';
                    cat.innerHTML = formatFormula(s.category);
                    nav.appendChild(cat);
                    lastCat = s.category;
                }
                
                const item = document.createElement('div');
                item.className = 'nav-item';
                item.innerHTML = `<span>${formatFormula(s.title)}</span>`;
                item.id = `nav-${i}`;
                item.onclick = () => {
                    // Manual override
                    state.demoMode = false;
                    document.getElementById('demo-switch').classList.remove('active');
                    document.getElementById('pause-btn').innerHTML = '<span>â–¶</span> ç»§ç»­æ¼”ç¤º';
                    loadStructure(i);
                };
                nav.appendChild(item);
            });
        }

        function updateNav(index) {
            document.querySelectorAll('.nav-item').forEach(el => el.classList.remove('active'));
            const curr = document.getElementById(`nav-${index}`);
            if(curr) {
                curr.classList.add('active');
                curr.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }

        function updateHUD(data) {
            // Title
            const titleEl = document.getElementById('main-title');
            const subEl = document.getElementById('sub-info');
            
            // Reset anim
            titleEl.classList.remove('visible');
            subEl.classList.remove('visible');
            
            setTimeout(() => {
                titleEl.innerHTML = formatFormula(data.title);
                subEl.innerHTML = formatFormula(data.category);
                titleEl.classList.add('visible');
                subEl.classList.add('visible');
            }, 100);

            // Keywords
            const keyContainer = document.getElementById('keywords-container');
            keyContainer.innerHTML = '';
            data.keywords.forEach((k, i) => {
                const tag = document.createElement('div');
                tag.className = 'keyword-tag';
                tag.innerHTML = formatFormula(k);
                tag.style.animationDelay = `${i * 0.2 + 0.5}s`;
                keyContainer.appendChild(tag);
            });

            // Info Panel
            document.getElementById('info-system').innerText = data.info.system;
            document.getElementById('info-cn').innerText = data.info.cn;
            document.getElementById('info-z').innerText = data.info.z;

            // Legend
            const legendContainer = document.getElementById('legend-container');
            legendContainer.innerHTML = '';
            const uniqueEls = [...new Set(data.generator().atoms.map(a => {
                let el = a.el;
                if(el.length === 2) el = el.charAt(0).toUpperCase() + el.charAt(1).toLowerCase();
                else el = el.toUpperCase();
                return el;
            }))];
            uniqueEls.forEach(el => {
                const div = document.createElement('div');
                div.className = 'legend-item';
                const colorHex = '#' + (CONFIG.colors[el] || 0xffffff).toString(16).padStart(6, '0');
                div.innerHTML = `<div class="legend-dot" style="background:${colorHex}; box-shadow: 0 0 8px ${colorHex}"></div> ${el}`;
                legendContainer.appendChild(div);
            });


            // CIF Export
            const existingCifBtn = document.getElementById('cif-btn');
            if(existingCifBtn) existingCifBtn.remove();
            
            if(data.cifData) {
                const btn = document.createElement('button');
                btn.id = 'cif-btn';
                btn.className = 'control-btn';
                btn.style.marginTop = '10px';
                btn.innerHTML = '<span>ğŸ“¥</span> å¯¼å‡º CIF';
                btn.onclick = () => {
                    downloadCIF(data);
                };
                document.getElementById('details-panel').appendChild(btn);
            }
        }
        
        function downloadCIF(data) {
            const cif = data.cifData;
            if(!cif) return;
            
            let content = `data_${data.id}\n`;
            content += `_audit_creation_date ${new Date().toISOString().split('T')[0]}\n`;
            content += `_audit_creation_method 'Crystal Vis Tool'\n`;
            content += `_symmetry_space_group_name_H-M '${cif.sg}'\n`;
            content += `_cell_length_a ${cif.a.toFixed(4)}\n`;
            content += `_cell_length_b ${cif.b.toFixed(4)}\n`;
            content += `_cell_length_c ${cif.c.toFixed(4)}\n`;
            content += `_cell_angle_alpha ${cif.alpha.toFixed(2)}\n`;
            content += `_cell_angle_beta ${cif.beta.toFixed(2)}\n`;
            content += `_cell_angle_gamma ${cif.gamma.toFixed(2)}\n`;
            content += `\nloop_\n_atom_site_label\n_atom_site_fract_x\n_atom_site_fract_y\n_atom_site_fract_z\n`;
            
            cif.atoms.forEach((a, i) => {
                content += `${a.label}${i+1} ${a.x.toFixed(5)} ${a.y.toFixed(5)} ${a.z.toFixed(5)}\n`;
            });
            
            // Trigger download
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${data.id}.cif`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // --- Controls ---
        function toggleDemoMode() {
            state.demoMode = !state.demoMode;
            const btn = document.getElementById('demo-switch');
            if(state.demoMode) {
                btn.classList.add('active');
                state.paused = false;
                document.getElementById('pause-btn').innerHTML = '<span>âšâš</span> æš‚åœæ¼”ç¤º';
                
                // Reset demo phase logic
                state.lastSwitchTime = Date.now();
                state.demoPhase = 0; 
                state.lastDemoActionTime = Date.now();
            } else {
                btn.classList.remove('active');
                controls.autoRotate = false;
                clearHighlights(); // å…³é—­æ¼”ç¤ºæ¨¡å¼æ—¶æ¸…é™¤é«˜äº®
            }
        }
        
        function toggleDimming() {
            state.enableDimming = !state.enableDimming;
            const btn = document.getElementById('dim-btn');
            if (state.enableDimming) {
                btn.classList.add('active');
                btn.innerHTML = '<span>ğŸ’¡</span> æš—åŒ–èƒŒæ™¯: å¼€';
                // å¦‚æœå½“å‰æœ‰é«˜äº®ï¼Œç«‹å³åº”ç”¨æš—åŒ–
                if (state.selectedAtom) {
                     // æ¸…é™¤å¹¶é‡æ–°é«˜äº®å¤ªå¤æ‚ï¼Œç®€å•æ¸…é™¤
                     clearHighlights();
                }
            } else {
                btn.classList.remove('active');
                btn.innerHTML = '<span>ğŸ’¡</span> æš—åŒ–èƒŒæ™¯: å…³';
                // ç«‹å³æ¢å¤æ‰€æœ‰æè´¨
                restoreMaterials();
            }
        }

        function togglePause() {
            state.paused = !state.paused;
            const btn = document.getElementById('pause-btn');
            if(state.paused) {
                btn.innerHTML = '<span>â–¶</span> ç»§ç»­æ¼”ç¤º';
            } else {
                btn.innerHTML = '<span>âšâš</span> æš‚åœæ¼”ç¤º';
                // Reset timer so it doesn't jump immediately
                state.lastSwitchTime = Date.now();
            }
        }

        function nextStructure() {
            let next = state.currentIndex + 1;
            if(next >= structures.length) next = 0;
            loadStructure(next);
        }

        function resetView() {
            // å¹³æ»‘å¤ä½è§†å›¾
            const targetPos = new THREE.Vector3(3, 2, 3); // åˆå§‹ç›¸æœºä½ç½®
            const targetLookAt = new THREE.Vector3(0, 0, 0); // åˆå§‹è§‚å¯Ÿç‚¹

            const startPos = camera.position.clone();
            const startLookAt = controls.target.clone();

            const startTime = Date.now();
            const duration = 1000; // æŒç»­1ç§’

            function animateReset() {
                const now = Date.now();
                const progress = Math.min((now - startTime) / duration, 1);
                // Ease out cubic ç¼“åŠ¨æ•ˆæœ
                const ease = 1 - Math.pow(1 - progress, 3);

                camera.position.lerpVectors(startPos, targetPos, ease);
                controls.target.lerpVectors(startLookAt, targetLookAt, ease);
                controls.update();

                if (progress < 1) {
                    requestAnimationFrame(animateReset);
                }
            }
            animateReset();
        }

        // Boot
        init();

    </script>
</body>
</html>
